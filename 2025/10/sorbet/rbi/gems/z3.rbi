# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/z3/all/z3.rbi
#
# z3-0.0.20251017

module Z3
  def Add(*args); end
  def And(*args); end
  def Bitvec(v, n); end
  def Bool(v); end
  def Const(v); end
  def Distinct(*args); end
  def Eq(*args); end
  def False; end
  def IfThenElse(a, b, c); end
  def Implies(a, b); end
  def Int(v); end
  def Mul(*args); end
  def Or(*args); end
  def Real(v); end
  def True; end
  def Xor(*args); end
  def set_param(k, v); end
  def version; end
  def version_at_least?(a, b = nil, c = nil, d = nil); end
end
module Z3::VeryLowLevel
  def Z3_add_const_interp(*arg0); end
  def Z3_add_func_interp(*arg0); end
  def Z3_algebraic_add(*arg0); end
  def Z3_algebraic_div(*arg0); end
  def Z3_algebraic_eq(*arg0); end
  def Z3_algebraic_ge(*arg0); end
  def Z3_algebraic_get_i(*arg0); end
  def Z3_algebraic_get_poly(*arg0); end
  def Z3_algebraic_gt(*arg0); end
  def Z3_algebraic_is_neg(*arg0); end
  def Z3_algebraic_is_pos(*arg0); end
  def Z3_algebraic_is_value(*arg0); end
  def Z3_algebraic_is_zero(*arg0); end
  def Z3_algebraic_le(*arg0); end
  def Z3_algebraic_lt(*arg0); end
  def Z3_algebraic_mul(*arg0); end
  def Z3_algebraic_neq(*arg0); end
  def Z3_algebraic_power(*arg0); end
  def Z3_algebraic_root(*arg0); end
  def Z3_algebraic_sign(*arg0); end
  def Z3_algebraic_sub(*arg0); end
  def Z3_apply_result_dec_ref(*arg0); end
  def Z3_apply_result_get_num_subgoals(*arg0); end
  def Z3_apply_result_get_subgoal(*arg0); end
  def Z3_apply_result_inc_ref(*arg0); end
  def Z3_apply_result_to_string(*arg0); end
  def Z3_ast_map_contains(*arg0); end
  def Z3_ast_map_dec_ref(*arg0); end
  def Z3_ast_map_erase(*arg0); end
  def Z3_ast_map_find(*arg0); end
  def Z3_ast_map_inc_ref(*arg0); end
  def Z3_ast_map_insert(*arg0); end
  def Z3_ast_map_keys(*arg0); end
  def Z3_ast_map_reset(*arg0); end
  def Z3_ast_map_size(*arg0); end
  def Z3_ast_map_to_string(*arg0); end
  def Z3_ast_to_string(*arg0); end
  def Z3_ast_vector_dec_ref(*arg0); end
  def Z3_ast_vector_get(*arg0); end
  def Z3_ast_vector_inc_ref(*arg0); end
  def Z3_ast_vector_push(*arg0); end
  def Z3_ast_vector_resize(*arg0); end
  def Z3_ast_vector_set(*arg0); end
  def Z3_ast_vector_size(*arg0); end
  def Z3_ast_vector_to_string(*arg0); end
  def Z3_ast_vector_translate(*arg0); end
  def Z3_constructor_num_fields(*arg0); end
  def Z3_datatype_update_field(*arg0); end
  def Z3_dec_ref(*arg0); end
  def Z3_del_config(*arg0); end
  def Z3_del_constructor(*arg0); end
  def Z3_del_constructor_list(*arg0); end
  def Z3_del_context(*arg0); end
  def Z3_disable_trace(*arg0); end
  def Z3_enable_concurrent_dec_ref(*arg0); end
  def Z3_enable_trace(*arg0); end
  def Z3_eval_smtlib2_string(*arg0); end
  def Z3_finalize_memory(*arg0); end
  def Z3_fixedpoint_add_cover(*arg0); end
  def Z3_fixedpoint_add_invariant(*arg0); end
  def Z3_fixedpoint_add_rule(*arg0); end
  def Z3_fixedpoint_assert(*arg0); end
  def Z3_fixedpoint_dec_ref(*arg0); end
  def Z3_fixedpoint_from_file(*arg0); end
  def Z3_fixedpoint_from_string(*arg0); end
  def Z3_fixedpoint_get_answer(*arg0); end
  def Z3_fixedpoint_get_assertions(*arg0); end
  def Z3_fixedpoint_get_cover_delta(*arg0); end
  def Z3_fixedpoint_get_ground_sat_answer(*arg0); end
  def Z3_fixedpoint_get_help(*arg0); end
  def Z3_fixedpoint_get_num_levels(*arg0); end
  def Z3_fixedpoint_get_param_descrs(*arg0); end
  def Z3_fixedpoint_get_reachable(*arg0); end
  def Z3_fixedpoint_get_reason_unknown(*arg0); end
  def Z3_fixedpoint_get_rule_names_along_trace(*arg0); end
  def Z3_fixedpoint_get_rules(*arg0); end
  def Z3_fixedpoint_get_rules_along_trace(*arg0); end
  def Z3_fixedpoint_get_statistics(*arg0); end
  def Z3_fixedpoint_inc_ref(*arg0); end
  def Z3_fixedpoint_query(*arg0); end
  def Z3_fixedpoint_query_from_lvl(*arg0); end
  def Z3_fixedpoint_register_relation(*arg0); end
  def Z3_fixedpoint_set_params(*arg0); end
  def Z3_fixedpoint_update_rule(*arg0); end
  def Z3_fpa_get_ebits(*arg0); end
  def Z3_fpa_get_numeral_exponent_bv(*arg0); end
  def Z3_fpa_get_numeral_exponent_string(*arg0); end
  def Z3_fpa_get_numeral_sign_bv(*arg0); end
  def Z3_fpa_get_numeral_significand_bv(*arg0); end
  def Z3_fpa_get_numeral_significand_string(*arg0); end
  def Z3_fpa_get_sbits(*arg0); end
  def Z3_fpa_is_numeral_inf(*arg0); end
  def Z3_fpa_is_numeral_nan(*arg0); end
  def Z3_fpa_is_numeral_negative(*arg0); end
  def Z3_fpa_is_numeral_normal(*arg0); end
  def Z3_fpa_is_numeral_positive(*arg0); end
  def Z3_fpa_is_numeral_subnormal(*arg0); end
  def Z3_fpa_is_numeral_zero(*arg0); end
  def Z3_func_entry_dec_ref(*arg0); end
  def Z3_func_entry_get_arg(*arg0); end
  def Z3_func_entry_get_num_args(*arg0); end
  def Z3_func_entry_get_value(*arg0); end
  def Z3_func_entry_inc_ref(*arg0); end
  def Z3_func_interp_add_entry(*arg0); end
  def Z3_func_interp_dec_ref(*arg0); end
  def Z3_func_interp_get_arity(*arg0); end
  def Z3_func_interp_get_else(*arg0); end
  def Z3_func_interp_get_entry(*arg0); end
  def Z3_func_interp_get_num_entries(*arg0); end
  def Z3_func_interp_inc_ref(*arg0); end
  def Z3_func_interp_set_else(*arg0); end
  def Z3_get_algebraic_number_lower(*arg0); end
  def Z3_get_algebraic_number_upper(*arg0); end
  def Z3_get_app_arg(*arg0); end
  def Z3_get_app_decl(*arg0); end
  def Z3_get_app_num_args(*arg0); end
  def Z3_get_arity(*arg0); end
  def Z3_get_array_arity(*arg0); end
  def Z3_get_array_sort_domain(*arg0); end
  def Z3_get_array_sort_domain_n(*arg0); end
  def Z3_get_array_sort_range(*arg0); end
  def Z3_get_as_array_func_decl(*arg0); end
  def Z3_get_ast_hash(*arg0); end
  def Z3_get_ast_id(*arg0); end
  def Z3_get_ast_kind(*arg0); end
  def Z3_get_bool_value(*arg0); end
  def Z3_get_bv_sort_size(*arg0); end
  def Z3_get_datatype_sort_constructor(*arg0); end
  def Z3_get_datatype_sort_constructor_accessor(*arg0); end
  def Z3_get_datatype_sort_num_constructors(*arg0); end
  def Z3_get_datatype_sort_recognizer(*arg0); end
  def Z3_get_decl_ast_parameter(*arg0); end
  def Z3_get_decl_double_parameter(*arg0); end
  def Z3_get_decl_func_decl_parameter(*arg0); end
  def Z3_get_decl_int_parameter(*arg0); end
  def Z3_get_decl_kind(*arg0); end
  def Z3_get_decl_name(*arg0); end
  def Z3_get_decl_num_parameters(*arg0); end
  def Z3_get_decl_parameter_kind(*arg0); end
  def Z3_get_decl_rational_parameter(*arg0); end
  def Z3_get_decl_sort_parameter(*arg0); end
  def Z3_get_decl_symbol_parameter(*arg0); end
  def Z3_get_denominator(*arg0); end
  def Z3_get_depth(*arg0); end
  def Z3_get_domain(*arg0); end
  def Z3_get_domain_size(*arg0); end
  def Z3_get_error_code(*arg0); end
  def Z3_get_full_version(*arg0); end
  def Z3_get_func_decl_id(*arg0); end
  def Z3_get_global_param_descrs(*arg0); end
  def Z3_get_index_value(*arg0); end
  def Z3_get_num_probes(*arg0); end
  def Z3_get_num_simplifiers(*arg0); end
  def Z3_get_num_tactics(*arg0); end
  def Z3_get_numeral_binary_string(*arg0); end
  def Z3_get_numeral_decimal_string(*arg0); end
  def Z3_get_numeral_double(*arg0); end
  def Z3_get_numeral_string(*arg0); end
  def Z3_get_numerator(*arg0); end
  def Z3_get_pattern(*arg0); end
  def Z3_get_pattern_num_terms(*arg0); end
  def Z3_get_probe_name(*arg0); end
  def Z3_get_quantifier_body(*arg0); end
  def Z3_get_quantifier_bound_name(*arg0); end
  def Z3_get_quantifier_bound_sort(*arg0); end
  def Z3_get_quantifier_id(*arg0); end
  def Z3_get_quantifier_no_pattern_ast(*arg0); end
  def Z3_get_quantifier_num_bound(*arg0); end
  def Z3_get_quantifier_num_no_patterns(*arg0); end
  def Z3_get_quantifier_num_patterns(*arg0); end
  def Z3_get_quantifier_pattern_ast(*arg0); end
  def Z3_get_quantifier_skolem_id(*arg0); end
  def Z3_get_quantifier_weight(*arg0); end
  def Z3_get_range(*arg0); end
  def Z3_get_re_sort_basis(*arg0); end
  def Z3_get_relation_arity(*arg0); end
  def Z3_get_relation_column(*arg0); end
  def Z3_get_seq_sort_basis(*arg0); end
  def Z3_get_simplifier_name(*arg0); end
  def Z3_get_sort(*arg0); end
  def Z3_get_sort_id(*arg0); end
  def Z3_get_sort_kind(*arg0); end
  def Z3_get_sort_name(*arg0); end
  def Z3_get_string_length(*arg0); end
  def Z3_get_symbol_int(*arg0); end
  def Z3_get_symbol_kind(*arg0); end
  def Z3_get_symbol_string(*arg0); end
  def Z3_get_tactic_name(*arg0); end
  def Z3_get_tuple_sort_field_decl(*arg0); end
  def Z3_get_tuple_sort_mk_decl(*arg0); end
  def Z3_get_tuple_sort_num_fields(*arg0); end
  def Z3_get_version(*arg0); end
  def Z3_global_param_reset_all(*arg0); end
  def Z3_global_param_set(*arg0); end
  def Z3_goal_assert(*arg0); end
  def Z3_goal_convert_model(*arg0); end
  def Z3_goal_dec_ref(*arg0); end
  def Z3_goal_depth(*arg0); end
  def Z3_goal_formula(*arg0); end
  def Z3_goal_inc_ref(*arg0); end
  def Z3_goal_inconsistent(*arg0); end
  def Z3_goal_is_decided_sat(*arg0); end
  def Z3_goal_is_decided_unsat(*arg0); end
  def Z3_goal_num_exprs(*arg0); end
  def Z3_goal_precision(*arg0); end
  def Z3_goal_reset(*arg0); end
  def Z3_goal_size(*arg0); end
  def Z3_goal_to_dimacs_string(*arg0); end
  def Z3_goal_to_string(*arg0); end
  def Z3_goal_translate(*arg0); end
  def Z3_inc_ref(*arg0); end
  def Z3_interrupt(*arg0); end
  def Z3_is_algebraic_number(*arg0); end
  def Z3_is_app(*arg0); end
  def Z3_is_as_array(*arg0); end
  def Z3_is_char_sort(*arg0); end
  def Z3_is_eq_ast(*arg0); end
  def Z3_is_eq_func_decl(*arg0); end
  def Z3_is_eq_sort(*arg0); end
  def Z3_is_ground(*arg0); end
  def Z3_is_lambda(*arg0); end
  def Z3_is_numeral_ast(*arg0); end
  def Z3_is_quantifier_exists(*arg0); end
  def Z3_is_quantifier_forall(*arg0); end
  def Z3_is_recursive_datatype_sort(*arg0); end
  def Z3_is_well_sorted(*arg0); end
  def Z3_mk_abs(*arg0); end
  def Z3_mk_add(*arg0); end
  def Z3_mk_and(*arg0); end
  def Z3_mk_array_default(*arg0); end
  def Z3_mk_array_sort(*arg0); end
  def Z3_mk_as_array(*arg0); end
  def Z3_mk_ast_map(*arg0); end
  def Z3_mk_ast_vector(*arg0); end
  def Z3_mk_bit2bool(*arg0); end
  def Z3_mk_bool_sort(*arg0); end
  def Z3_mk_bound(*arg0); end
  def Z3_mk_bv2int(*arg0); end
  def Z3_mk_bv_sort(*arg0); end
  def Z3_mk_bvadd(*arg0); end
  def Z3_mk_bvadd_no_overflow(*arg0); end
  def Z3_mk_bvadd_no_underflow(*arg0); end
  def Z3_mk_bvand(*arg0); end
  def Z3_mk_bvashr(*arg0); end
  def Z3_mk_bvlshr(*arg0); end
  def Z3_mk_bvmul(*arg0); end
  def Z3_mk_bvmul_no_overflow(*arg0); end
  def Z3_mk_bvmul_no_underflow(*arg0); end
  def Z3_mk_bvnand(*arg0); end
  def Z3_mk_bvneg(*arg0); end
  def Z3_mk_bvneg_no_overflow(*arg0); end
  def Z3_mk_bvnor(*arg0); end
  def Z3_mk_bvnot(*arg0); end
  def Z3_mk_bvor(*arg0); end
  def Z3_mk_bvredand(*arg0); end
  def Z3_mk_bvredor(*arg0); end
  def Z3_mk_bvsdiv(*arg0); end
  def Z3_mk_bvsdiv_no_overflow(*arg0); end
  def Z3_mk_bvsge(*arg0); end
  def Z3_mk_bvsgt(*arg0); end
  def Z3_mk_bvshl(*arg0); end
  def Z3_mk_bvsle(*arg0); end
  def Z3_mk_bvslt(*arg0); end
  def Z3_mk_bvsmod(*arg0); end
  def Z3_mk_bvsrem(*arg0); end
  def Z3_mk_bvsub(*arg0); end
  def Z3_mk_bvsub_no_overflow(*arg0); end
  def Z3_mk_bvsub_no_underflow(*arg0); end
  def Z3_mk_bvudiv(*arg0); end
  def Z3_mk_bvuge(*arg0); end
  def Z3_mk_bvugt(*arg0); end
  def Z3_mk_bvule(*arg0); end
  def Z3_mk_bvult(*arg0); end
  def Z3_mk_bvurem(*arg0); end
  def Z3_mk_bvxnor(*arg0); end
  def Z3_mk_bvxor(*arg0); end
  def Z3_mk_char(*arg0); end
  def Z3_mk_char_from_bv(*arg0); end
  def Z3_mk_char_is_digit(*arg0); end
  def Z3_mk_char_le(*arg0); end
  def Z3_mk_char_sort(*arg0); end
  def Z3_mk_char_to_bv(*arg0); end
  def Z3_mk_char_to_int(*arg0); end
  def Z3_mk_concat(*arg0); end
  def Z3_mk_config(*arg0); end
  def Z3_mk_const(*arg0); end
  def Z3_mk_const_array(*arg0); end
  def Z3_mk_context(*arg0); end
  def Z3_mk_context_rc(*arg0); end
  def Z3_mk_datatype_sort(*arg0); end
  def Z3_mk_distinct(*arg0); end
  def Z3_mk_div(*arg0); end
  def Z3_mk_divides(*arg0); end
  def Z3_mk_empty_set(*arg0); end
  def Z3_mk_eq(*arg0); end
  def Z3_mk_ext_rotate_left(*arg0); end
  def Z3_mk_ext_rotate_right(*arg0); end
  def Z3_mk_extract(*arg0); end
  def Z3_mk_false(*arg0); end
  def Z3_mk_finite_domain_sort(*arg0); end
  def Z3_mk_fixedpoint(*arg0); end
  def Z3_mk_fpa_abs(*arg0); end
  def Z3_mk_fpa_add(*arg0); end
  def Z3_mk_fpa_div(*arg0); end
  def Z3_mk_fpa_eq(*arg0); end
  def Z3_mk_fpa_fma(*arg0); end
  def Z3_mk_fpa_fp(*arg0); end
  def Z3_mk_fpa_geq(*arg0); end
  def Z3_mk_fpa_gt(*arg0); end
  def Z3_mk_fpa_inf(*arg0); end
  def Z3_mk_fpa_is_infinite(*arg0); end
  def Z3_mk_fpa_is_nan(*arg0); end
  def Z3_mk_fpa_is_negative(*arg0); end
  def Z3_mk_fpa_is_normal(*arg0); end
  def Z3_mk_fpa_is_positive(*arg0); end
  def Z3_mk_fpa_is_subnormal(*arg0); end
  def Z3_mk_fpa_is_zero(*arg0); end
  def Z3_mk_fpa_leq(*arg0); end
  def Z3_mk_fpa_lt(*arg0); end
  def Z3_mk_fpa_max(*arg0); end
  def Z3_mk_fpa_min(*arg0); end
  def Z3_mk_fpa_mul(*arg0); end
  def Z3_mk_fpa_nan(*arg0); end
  def Z3_mk_fpa_neg(*arg0); end
  def Z3_mk_fpa_numeral_double(*arg0); end
  def Z3_mk_fpa_numeral_int(*arg0); end
  def Z3_mk_fpa_numeral_int64_uint64(*arg0); end
  def Z3_mk_fpa_numeral_int_uint(*arg0); end
  def Z3_mk_fpa_rem(*arg0); end
  def Z3_mk_fpa_round_nearest_ties_to_away(*arg0); end
  def Z3_mk_fpa_round_nearest_ties_to_even(*arg0); end
  def Z3_mk_fpa_round_to_integral(*arg0); end
  def Z3_mk_fpa_round_toward_negative(*arg0); end
  def Z3_mk_fpa_round_toward_positive(*arg0); end
  def Z3_mk_fpa_round_toward_zero(*arg0); end
  def Z3_mk_fpa_rounding_mode_sort(*arg0); end
  def Z3_mk_fpa_sort(*arg0); end
  def Z3_mk_fpa_sort_128(*arg0); end
  def Z3_mk_fpa_sort_16(*arg0); end
  def Z3_mk_fpa_sort_32(*arg0); end
  def Z3_mk_fpa_sort_64(*arg0); end
  def Z3_mk_fpa_sort_double(*arg0); end
  def Z3_mk_fpa_sort_half(*arg0); end
  def Z3_mk_fpa_sort_quadruple(*arg0); end
  def Z3_mk_fpa_sort_single(*arg0); end
  def Z3_mk_fpa_sqrt(*arg0); end
  def Z3_mk_fpa_sub(*arg0); end
  def Z3_mk_fpa_to_fp_bv(*arg0); end
  def Z3_mk_fpa_to_fp_float(*arg0); end
  def Z3_mk_fpa_to_fp_int_real(*arg0); end
  def Z3_mk_fpa_to_fp_real(*arg0); end
  def Z3_mk_fpa_to_fp_signed(*arg0); end
  def Z3_mk_fpa_to_fp_unsigned(*arg0); end
  def Z3_mk_fpa_to_ieee_bv(*arg0); end
  def Z3_mk_fpa_to_real(*arg0); end
  def Z3_mk_fpa_to_sbv(*arg0); end
  def Z3_mk_fpa_to_ubv(*arg0); end
  def Z3_mk_fpa_zero(*arg0); end
  def Z3_mk_fresh_const(*arg0); end
  def Z3_mk_full_set(*arg0); end
  def Z3_mk_ge(*arg0); end
  def Z3_mk_goal(*arg0); end
  def Z3_mk_gt(*arg0); end
  def Z3_mk_iff(*arg0); end
  def Z3_mk_implies(*arg0); end
  def Z3_mk_int(*arg0); end
  def Z3_mk_int2bv(*arg0); end
  def Z3_mk_int2real(*arg0); end
  def Z3_mk_int64(*arg0); end
  def Z3_mk_int_sort(*arg0); end
  def Z3_mk_int_symbol(*arg0); end
  def Z3_mk_int_to_str(*arg0); end
  def Z3_mk_is_int(*arg0); end
  def Z3_mk_ite(*arg0); end
  def Z3_mk_le(*arg0); end
  def Z3_mk_linear_order(*arg0); end
  def Z3_mk_lstring(*arg0); end
  def Z3_mk_lt(*arg0); end
  def Z3_mk_mod(*arg0); end
  def Z3_mk_model(*arg0); end
  def Z3_mk_mul(*arg0); end
  def Z3_mk_not(*arg0); end
  def Z3_mk_numeral(*arg0); end
  def Z3_mk_optimize(*arg0); end
  def Z3_mk_or(*arg0); end
  def Z3_mk_params(*arg0); end
  def Z3_mk_partial_order(*arg0); end
  def Z3_mk_piecewise_linear_order(*arg0); end
  def Z3_mk_power(*arg0); end
  def Z3_mk_probe(*arg0); end
  def Z3_mk_re_allchar(*arg0); end
  def Z3_mk_re_complement(*arg0); end
  def Z3_mk_re_diff(*arg0); end
  def Z3_mk_re_empty(*arg0); end
  def Z3_mk_re_full(*arg0); end
  def Z3_mk_re_loop(*arg0); end
  def Z3_mk_re_power(*arg0); end
  def Z3_mk_re_range(*arg0); end
  def Z3_mk_real(*arg0); end
  def Z3_mk_real2int(*arg0); end
  def Z3_mk_real_int64(*arg0); end
  def Z3_mk_real_sort(*arg0); end
  def Z3_mk_rem(*arg0); end
  def Z3_mk_repeat(*arg0); end
  def Z3_mk_rotate_left(*arg0); end
  def Z3_mk_rotate_right(*arg0); end
  def Z3_mk_sbv_to_str(*arg0); end
  def Z3_mk_select(*arg0); end
  def Z3_mk_seq_foldl(*arg0); end
  def Z3_mk_seq_foldli(*arg0); end
  def Z3_mk_seq_last_index(*arg0); end
  def Z3_mk_seq_map(*arg0); end
  def Z3_mk_seq_mapi(*arg0); end
  def Z3_mk_seq_nth(*arg0); end
  def Z3_mk_set_add(*arg0); end
  def Z3_mk_set_complement(*arg0); end
  def Z3_mk_set_del(*arg0); end
  def Z3_mk_set_difference(*arg0); end
  def Z3_mk_set_has_size(*arg0); end
  def Z3_mk_set_intersect(*arg0); end
  def Z3_mk_set_member(*arg0); end
  def Z3_mk_set_sort(*arg0); end
  def Z3_mk_set_subset(*arg0); end
  def Z3_mk_set_union(*arg0); end
  def Z3_mk_sign_ext(*arg0); end
  def Z3_mk_simple_solver(*arg0); end
  def Z3_mk_solver(*arg0); end
  def Z3_mk_solver_for_logic(*arg0); end
  def Z3_mk_solver_from_tactic(*arg0); end
  def Z3_mk_store(*arg0); end
  def Z3_mk_str_le(*arg0); end
  def Z3_mk_str_lt(*arg0); end
  def Z3_mk_str_to_int(*arg0); end
  def Z3_mk_string_from_code(*arg0); end
  def Z3_mk_string_symbol(*arg0); end
  def Z3_mk_string_to_code(*arg0); end
  def Z3_mk_sub(*arg0); end
  def Z3_mk_tactic(*arg0); end
  def Z3_mk_transitive_closure(*arg0); end
  def Z3_mk_tree_order(*arg0); end
  def Z3_mk_true(*arg0); end
  def Z3_mk_type_variable(*arg0); end
  def Z3_mk_ubv_to_str(*arg0); end
  def Z3_mk_unary_minus(*arg0); end
  def Z3_mk_uninterpreted_sort(*arg0); end
  def Z3_mk_unsigned_int(*arg0); end
  def Z3_mk_unsigned_int64(*arg0); end
  def Z3_mk_xor(*arg0); end
  def Z3_mk_zero_ext(*arg0); end
  def Z3_model_dec_ref(*arg0); end
  def Z3_model_eval(*arg0); end
  def Z3_model_extrapolate(*arg0); end
  def Z3_model_get_const_decl(*arg0); end
  def Z3_model_get_const_interp(*arg0); end
  def Z3_model_get_func_decl(*arg0); end
  def Z3_model_get_func_interp(*arg0); end
  def Z3_model_get_num_consts(*arg0); end
  def Z3_model_get_num_funcs(*arg0); end
  def Z3_model_get_num_sorts(*arg0); end
  def Z3_model_get_sort(*arg0); end
  def Z3_model_get_sort_universe(*arg0); end
  def Z3_model_has_interp(*arg0); end
  def Z3_model_inc_ref(*arg0); end
  def Z3_model_to_string(*arg0); end
  def Z3_model_translate(*arg0); end
  def Z3_optimize_assert(*arg0); end
  def Z3_optimize_assert_and_track(*arg0); end
  def Z3_optimize_assert_soft(*arg0); end
  def Z3_optimize_check(*arg0); end
  def Z3_optimize_dec_ref(*arg0); end
  def Z3_optimize_from_file(*arg0); end
  def Z3_optimize_from_string(*arg0); end
  def Z3_optimize_get_assertions(*arg0); end
  def Z3_optimize_get_help(*arg0); end
  def Z3_optimize_get_lower(*arg0); end
  def Z3_optimize_get_lower_as_vector(*arg0); end
  def Z3_optimize_get_model(*arg0); end
  def Z3_optimize_get_objectives(*arg0); end
  def Z3_optimize_get_param_descrs(*arg0); end
  def Z3_optimize_get_reason_unknown(*arg0); end
  def Z3_optimize_get_statistics(*arg0); end
  def Z3_optimize_get_unsat_core(*arg0); end
  def Z3_optimize_get_upper(*arg0); end
  def Z3_optimize_get_upper_as_vector(*arg0); end
  def Z3_optimize_inc_ref(*arg0); end
  def Z3_optimize_maximize(*arg0); end
  def Z3_optimize_minimize(*arg0); end
  def Z3_optimize_pop(*arg0); end
  def Z3_optimize_push(*arg0); end
  def Z3_optimize_set_initial_value(*arg0); end
  def Z3_optimize_set_params(*arg0); end
  def Z3_optimize_to_string(*arg0); end
  def Z3_param_descrs_dec_ref(*arg0); end
  def Z3_param_descrs_get_kind(*arg0); end
  def Z3_param_descrs_get_name(*arg0); end
  def Z3_param_descrs_inc_ref(*arg0); end
  def Z3_param_descrs_size(*arg0); end
  def Z3_param_descrs_to_string(*arg0); end
  def Z3_params_dec_ref(*arg0); end
  def Z3_params_inc_ref(*arg0); end
  def Z3_params_set_bool(*arg0); end
  def Z3_params_set_double(*arg0); end
  def Z3_params_set_symbol(*arg0); end
  def Z3_params_set_uint(*arg0); end
  def Z3_params_to_string(*arg0); end
  def Z3_params_validate(*arg0); end
  def Z3_pattern_to_string(*arg0); end
  def Z3_polynomial_subresultants(*arg0); end
  def Z3_probe_and(*arg0); end
  def Z3_probe_apply(*arg0); end
  def Z3_probe_const(*arg0); end
  def Z3_probe_dec_ref(*arg0); end
  def Z3_probe_eq(*arg0); end
  def Z3_probe_ge(*arg0); end
  def Z3_probe_get_descr(*arg0); end
  def Z3_probe_gt(*arg0); end
  def Z3_probe_inc_ref(*arg0); end
  def Z3_probe_le(*arg0); end
  def Z3_probe_lt(*arg0); end
  def Z3_probe_not(*arg0); end
  def Z3_probe_or(*arg0); end
  def Z3_qe_lite(*arg0); end
  def Z3_rcf_add(*arg0); end
  def Z3_rcf_coefficient(*arg0); end
  def Z3_rcf_del(*arg0); end
  def Z3_rcf_div(*arg0); end
  def Z3_rcf_eq(*arg0); end
  def Z3_rcf_extension_index(*arg0); end
  def Z3_rcf_ge(*arg0); end
  def Z3_rcf_gt(*arg0); end
  def Z3_rcf_infinitesimal_name(*arg0); end
  def Z3_rcf_inv(*arg0); end
  def Z3_rcf_is_algebraic(*arg0); end
  def Z3_rcf_is_infinitesimal(*arg0); end
  def Z3_rcf_is_rational(*arg0); end
  def Z3_rcf_is_transcendental(*arg0); end
  def Z3_rcf_le(*arg0); end
  def Z3_rcf_lt(*arg0); end
  def Z3_rcf_mk_e(*arg0); end
  def Z3_rcf_mk_infinitesimal(*arg0); end
  def Z3_rcf_mk_pi(*arg0); end
  def Z3_rcf_mk_rational(*arg0); end
  def Z3_rcf_mk_small_int(*arg0); end
  def Z3_rcf_mul(*arg0); end
  def Z3_rcf_neg(*arg0); end
  def Z3_rcf_neq(*arg0); end
  def Z3_rcf_num_coefficients(*arg0); end
  def Z3_rcf_num_sign_condition_coefficients(*arg0); end
  def Z3_rcf_num_sign_conditions(*arg0); end
  def Z3_rcf_num_to_decimal_string(*arg0); end
  def Z3_rcf_num_to_string(*arg0); end
  def Z3_rcf_power(*arg0); end
  def Z3_rcf_sign_condition_coefficient(*arg0); end
  def Z3_rcf_sign_condition_sign(*arg0); end
  def Z3_rcf_sub(*arg0); end
  def Z3_rcf_transcendental_name(*arg0); end
  def Z3_reset_memory(*arg0); end
  def Z3_set_error_handler(*arg0); end
  def Z3_set_param_value(*arg0); end
  def Z3_simplifier_get_descr(*arg0); end
  def Z3_simplify(*arg0); end
  def Z3_simplify_ex(*arg0); end
  def Z3_simplify_get_help(*arg0); end
  def Z3_simplify_get_param_descrs(*arg0); end
  def Z3_solver_assert(*arg0); end
  def Z3_solver_assert_and_track(*arg0); end
  def Z3_solver_check(*arg0); end
  def Z3_solver_congruence_explain(*arg0); end
  def Z3_solver_congruence_next(*arg0); end
  def Z3_solver_congruence_root(*arg0); end
  def Z3_solver_cube(*arg0); end
  def Z3_solver_dec_ref(*arg0); end
  def Z3_solver_from_file(*arg0); end
  def Z3_solver_from_string(*arg0); end
  def Z3_solver_get_assertions(*arg0); end
  def Z3_solver_get_consequences(*arg0); end
  def Z3_solver_get_help(*arg0); end
  def Z3_solver_get_model(*arg0); end
  def Z3_solver_get_non_units(*arg0); end
  def Z3_solver_get_num_scopes(*arg0); end
  def Z3_solver_get_param_descrs(*arg0); end
  def Z3_solver_get_proof(*arg0); end
  def Z3_solver_get_reason_unknown(*arg0); end
  def Z3_solver_get_statistics(*arg0); end
  def Z3_solver_get_trail(*arg0); end
  def Z3_solver_get_units(*arg0); end
  def Z3_solver_get_unsat_core(*arg0); end
  def Z3_solver_import_model_converter(*arg0); end
  def Z3_solver_inc_ref(*arg0); end
  def Z3_solver_interrupt(*arg0); end
  def Z3_solver_pop(*arg0); end
  def Z3_solver_propagate_register(*arg0); end
  def Z3_solver_push(*arg0); end
  def Z3_solver_reset(*arg0); end
  def Z3_solver_set_initial_value(*arg0); end
  def Z3_solver_set_params(*arg0); end
  def Z3_solver_solve_for(*arg0); end
  def Z3_solver_to_dimacs_string(*arg0); end
  def Z3_solver_to_string(*arg0); end
  def Z3_stats_dec_ref(*arg0); end
  def Z3_stats_get_double_value(*arg0); end
  def Z3_stats_get_key(*arg0); end
  def Z3_stats_get_uint_value(*arg0); end
  def Z3_stats_inc_ref(*arg0); end
  def Z3_stats_is_double(*arg0); end
  def Z3_stats_is_uint(*arg0); end
  def Z3_stats_size(*arg0); end
  def Z3_stats_to_string(*arg0); end
  def Z3_tactic_and_then(*arg0); end
  def Z3_tactic_apply(*arg0); end
  def Z3_tactic_apply_ex(*arg0); end
  def Z3_tactic_cond(*arg0); end
  def Z3_tactic_dec_ref(*arg0); end
  def Z3_tactic_fail(*arg0); end
  def Z3_tactic_fail_if(*arg0); end
  def Z3_tactic_fail_if_not_decided(*arg0); end
  def Z3_tactic_get_descr(*arg0); end
  def Z3_tactic_get_help(*arg0); end
  def Z3_tactic_get_param_descrs(*arg0); end
  def Z3_tactic_inc_ref(*arg0); end
  def Z3_tactic_or_else(*arg0); end
  def Z3_tactic_par_and_then(*arg0); end
  def Z3_tactic_repeat(*arg0); end
  def Z3_tactic_skip(*arg0); end
  def Z3_tactic_try_for(*arg0); end
  def Z3_tactic_using_params(*arg0); end
  def Z3_tactic_when(*arg0); end
  def Z3_toggle_warning_messages(*arg0); end
  def Z3_translate(*arg0); end
  def Z3_update_param_value(*arg0); end
  def self.Z3_add_const_interp(*arg0); end
  def self.Z3_add_func_interp(*arg0); end
  def self.Z3_algebraic_add(*arg0); end
  def self.Z3_algebraic_div(*arg0); end
  def self.Z3_algebraic_eq(*arg0); end
  def self.Z3_algebraic_ge(*arg0); end
  def self.Z3_algebraic_get_i(*arg0); end
  def self.Z3_algebraic_get_poly(*arg0); end
  def self.Z3_algebraic_gt(*arg0); end
  def self.Z3_algebraic_is_neg(*arg0); end
  def self.Z3_algebraic_is_pos(*arg0); end
  def self.Z3_algebraic_is_value(*arg0); end
  def self.Z3_algebraic_is_zero(*arg0); end
  def self.Z3_algebraic_le(*arg0); end
  def self.Z3_algebraic_lt(*arg0); end
  def self.Z3_algebraic_mul(*arg0); end
  def self.Z3_algebraic_neq(*arg0); end
  def self.Z3_algebraic_power(*arg0); end
  def self.Z3_algebraic_root(*arg0); end
  def self.Z3_algebraic_sign(*arg0); end
  def self.Z3_algebraic_sub(*arg0); end
  def self.Z3_apply_result_dec_ref(*arg0); end
  def self.Z3_apply_result_get_num_subgoals(*arg0); end
  def self.Z3_apply_result_get_subgoal(*arg0); end
  def self.Z3_apply_result_inc_ref(*arg0); end
  def self.Z3_apply_result_to_string(*arg0); end
  def self.Z3_ast_map_contains(*arg0); end
  def self.Z3_ast_map_dec_ref(*arg0); end
  def self.Z3_ast_map_erase(*arg0); end
  def self.Z3_ast_map_find(*arg0); end
  def self.Z3_ast_map_inc_ref(*arg0); end
  def self.Z3_ast_map_insert(*arg0); end
  def self.Z3_ast_map_keys(*arg0); end
  def self.Z3_ast_map_reset(*arg0); end
  def self.Z3_ast_map_size(*arg0); end
  def self.Z3_ast_map_to_string(*arg0); end
  def self.Z3_ast_to_string(*arg0); end
  def self.Z3_ast_vector_dec_ref(*arg0); end
  def self.Z3_ast_vector_get(*arg0); end
  def self.Z3_ast_vector_inc_ref(*arg0); end
  def self.Z3_ast_vector_push(*arg0); end
  def self.Z3_ast_vector_resize(*arg0); end
  def self.Z3_ast_vector_set(*arg0); end
  def self.Z3_ast_vector_size(*arg0); end
  def self.Z3_ast_vector_to_string(*arg0); end
  def self.Z3_ast_vector_translate(*arg0); end
  def self.Z3_constructor_num_fields(*arg0); end
  def self.Z3_datatype_update_field(*arg0); end
  def self.Z3_dec_ref(*arg0); end
  def self.Z3_del_config(*arg0); end
  def self.Z3_del_constructor(*arg0); end
  def self.Z3_del_constructor_list(*arg0); end
  def self.Z3_del_context(*arg0); end
  def self.Z3_disable_trace(*arg0); end
  def self.Z3_enable_concurrent_dec_ref(*arg0); end
  def self.Z3_enable_trace(*arg0); end
  def self.Z3_eval_smtlib2_string(*arg0); end
  def self.Z3_finalize_memory(*arg0); end
  def self.Z3_fixedpoint_add_cover(*arg0); end
  def self.Z3_fixedpoint_add_invariant(*arg0); end
  def self.Z3_fixedpoint_add_rule(*arg0); end
  def self.Z3_fixedpoint_assert(*arg0); end
  def self.Z3_fixedpoint_dec_ref(*arg0); end
  def self.Z3_fixedpoint_from_file(*arg0); end
  def self.Z3_fixedpoint_from_string(*arg0); end
  def self.Z3_fixedpoint_get_answer(*arg0); end
  def self.Z3_fixedpoint_get_assertions(*arg0); end
  def self.Z3_fixedpoint_get_cover_delta(*arg0); end
  def self.Z3_fixedpoint_get_ground_sat_answer(*arg0); end
  def self.Z3_fixedpoint_get_help(*arg0); end
  def self.Z3_fixedpoint_get_num_levels(*arg0); end
  def self.Z3_fixedpoint_get_param_descrs(*arg0); end
  def self.Z3_fixedpoint_get_reachable(*arg0); end
  def self.Z3_fixedpoint_get_reason_unknown(*arg0); end
  def self.Z3_fixedpoint_get_rule_names_along_trace(*arg0); end
  def self.Z3_fixedpoint_get_rules(*arg0); end
  def self.Z3_fixedpoint_get_rules_along_trace(*arg0); end
  def self.Z3_fixedpoint_get_statistics(*arg0); end
  def self.Z3_fixedpoint_inc_ref(*arg0); end
  def self.Z3_fixedpoint_query(*arg0); end
  def self.Z3_fixedpoint_query_from_lvl(*arg0); end
  def self.Z3_fixedpoint_register_relation(*arg0); end
  def self.Z3_fixedpoint_set_params(*arg0); end
  def self.Z3_fixedpoint_update_rule(*arg0); end
  def self.Z3_fpa_get_ebits(*arg0); end
  def self.Z3_fpa_get_numeral_exponent_bv(*arg0); end
  def self.Z3_fpa_get_numeral_exponent_string(*arg0); end
  def self.Z3_fpa_get_numeral_sign_bv(*arg0); end
  def self.Z3_fpa_get_numeral_significand_bv(*arg0); end
  def self.Z3_fpa_get_numeral_significand_string(*arg0); end
  def self.Z3_fpa_get_sbits(*arg0); end
  def self.Z3_fpa_is_numeral_inf(*arg0); end
  def self.Z3_fpa_is_numeral_nan(*arg0); end
  def self.Z3_fpa_is_numeral_negative(*arg0); end
  def self.Z3_fpa_is_numeral_normal(*arg0); end
  def self.Z3_fpa_is_numeral_positive(*arg0); end
  def self.Z3_fpa_is_numeral_subnormal(*arg0); end
  def self.Z3_fpa_is_numeral_zero(*arg0); end
  def self.Z3_func_entry_dec_ref(*arg0); end
  def self.Z3_func_entry_get_arg(*arg0); end
  def self.Z3_func_entry_get_num_args(*arg0); end
  def self.Z3_func_entry_get_value(*arg0); end
  def self.Z3_func_entry_inc_ref(*arg0); end
  def self.Z3_func_interp_add_entry(*arg0); end
  def self.Z3_func_interp_dec_ref(*arg0); end
  def self.Z3_func_interp_get_arity(*arg0); end
  def self.Z3_func_interp_get_else(*arg0); end
  def self.Z3_func_interp_get_entry(*arg0); end
  def self.Z3_func_interp_get_num_entries(*arg0); end
  def self.Z3_func_interp_inc_ref(*arg0); end
  def self.Z3_func_interp_set_else(*arg0); end
  def self.Z3_get_algebraic_number_lower(*arg0); end
  def self.Z3_get_algebraic_number_upper(*arg0); end
  def self.Z3_get_app_arg(*arg0); end
  def self.Z3_get_app_decl(*arg0); end
  def self.Z3_get_app_num_args(*arg0); end
  def self.Z3_get_arity(*arg0); end
  def self.Z3_get_array_arity(*arg0); end
  def self.Z3_get_array_sort_domain(*arg0); end
  def self.Z3_get_array_sort_domain_n(*arg0); end
  def self.Z3_get_array_sort_range(*arg0); end
  def self.Z3_get_as_array_func_decl(*arg0); end
  def self.Z3_get_ast_hash(*arg0); end
  def self.Z3_get_ast_id(*arg0); end
  def self.Z3_get_ast_kind(*arg0); end
  def self.Z3_get_bool_value(*arg0); end
  def self.Z3_get_bv_sort_size(*arg0); end
  def self.Z3_get_datatype_sort_constructor(*arg0); end
  def self.Z3_get_datatype_sort_constructor_accessor(*arg0); end
  def self.Z3_get_datatype_sort_num_constructors(*arg0); end
  def self.Z3_get_datatype_sort_recognizer(*arg0); end
  def self.Z3_get_decl_ast_parameter(*arg0); end
  def self.Z3_get_decl_double_parameter(*arg0); end
  def self.Z3_get_decl_func_decl_parameter(*arg0); end
  def self.Z3_get_decl_int_parameter(*arg0); end
  def self.Z3_get_decl_kind(*arg0); end
  def self.Z3_get_decl_name(*arg0); end
  def self.Z3_get_decl_num_parameters(*arg0); end
  def self.Z3_get_decl_parameter_kind(*arg0); end
  def self.Z3_get_decl_rational_parameter(*arg0); end
  def self.Z3_get_decl_sort_parameter(*arg0); end
  def self.Z3_get_decl_symbol_parameter(*arg0); end
  def self.Z3_get_denominator(*arg0); end
  def self.Z3_get_depth(*arg0); end
  def self.Z3_get_domain(*arg0); end
  def self.Z3_get_domain_size(*arg0); end
  def self.Z3_get_error_code(*arg0); end
  def self.Z3_get_full_version(*arg0); end
  def self.Z3_get_func_decl_id(*arg0); end
  def self.Z3_get_global_param_descrs(*arg0); end
  def self.Z3_get_index_value(*arg0); end
  def self.Z3_get_num_probes(*arg0); end
  def self.Z3_get_num_simplifiers(*arg0); end
  def self.Z3_get_num_tactics(*arg0); end
  def self.Z3_get_numeral_binary_string(*arg0); end
  def self.Z3_get_numeral_decimal_string(*arg0); end
  def self.Z3_get_numeral_double(*arg0); end
  def self.Z3_get_numeral_string(*arg0); end
  def self.Z3_get_numerator(*arg0); end
  def self.Z3_get_pattern(*arg0); end
  def self.Z3_get_pattern_num_terms(*arg0); end
  def self.Z3_get_probe_name(*arg0); end
  def self.Z3_get_quantifier_body(*arg0); end
  def self.Z3_get_quantifier_bound_name(*arg0); end
  def self.Z3_get_quantifier_bound_sort(*arg0); end
  def self.Z3_get_quantifier_id(*arg0); end
  def self.Z3_get_quantifier_no_pattern_ast(*arg0); end
  def self.Z3_get_quantifier_num_bound(*arg0); end
  def self.Z3_get_quantifier_num_no_patterns(*arg0); end
  def self.Z3_get_quantifier_num_patterns(*arg0); end
  def self.Z3_get_quantifier_pattern_ast(*arg0); end
  def self.Z3_get_quantifier_skolem_id(*arg0); end
  def self.Z3_get_quantifier_weight(*arg0); end
  def self.Z3_get_range(*arg0); end
  def self.Z3_get_re_sort_basis(*arg0); end
  def self.Z3_get_relation_arity(*arg0); end
  def self.Z3_get_relation_column(*arg0); end
  def self.Z3_get_seq_sort_basis(*arg0); end
  def self.Z3_get_simplifier_name(*arg0); end
  def self.Z3_get_sort(*arg0); end
  def self.Z3_get_sort_id(*arg0); end
  def self.Z3_get_sort_kind(*arg0); end
  def self.Z3_get_sort_name(*arg0); end
  def self.Z3_get_string_length(*arg0); end
  def self.Z3_get_symbol_int(*arg0); end
  def self.Z3_get_symbol_kind(*arg0); end
  def self.Z3_get_symbol_string(*arg0); end
  def self.Z3_get_tactic_name(*arg0); end
  def self.Z3_get_tuple_sort_field_decl(*arg0); end
  def self.Z3_get_tuple_sort_mk_decl(*arg0); end
  def self.Z3_get_tuple_sort_num_fields(*arg0); end
  def self.Z3_get_version(*arg0); end
  def self.Z3_global_param_reset_all(*arg0); end
  def self.Z3_global_param_set(*arg0); end
  def self.Z3_goal_assert(*arg0); end
  def self.Z3_goal_convert_model(*arg0); end
  def self.Z3_goal_dec_ref(*arg0); end
  def self.Z3_goal_depth(*arg0); end
  def self.Z3_goal_formula(*arg0); end
  def self.Z3_goal_inc_ref(*arg0); end
  def self.Z3_goal_inconsistent(*arg0); end
  def self.Z3_goal_is_decided_sat(*arg0); end
  def self.Z3_goal_is_decided_unsat(*arg0); end
  def self.Z3_goal_num_exprs(*arg0); end
  def self.Z3_goal_precision(*arg0); end
  def self.Z3_goal_reset(*arg0); end
  def self.Z3_goal_size(*arg0); end
  def self.Z3_goal_to_dimacs_string(*arg0); end
  def self.Z3_goal_to_string(*arg0); end
  def self.Z3_goal_translate(*arg0); end
  def self.Z3_inc_ref(*arg0); end
  def self.Z3_interrupt(*arg0); end
  def self.Z3_is_algebraic_number(*arg0); end
  def self.Z3_is_app(*arg0); end
  def self.Z3_is_as_array(*arg0); end
  def self.Z3_is_char_sort(*arg0); end
  def self.Z3_is_eq_ast(*arg0); end
  def self.Z3_is_eq_func_decl(*arg0); end
  def self.Z3_is_eq_sort(*arg0); end
  def self.Z3_is_ground(*arg0); end
  def self.Z3_is_lambda(*arg0); end
  def self.Z3_is_numeral_ast(*arg0); end
  def self.Z3_is_quantifier_exists(*arg0); end
  def self.Z3_is_quantifier_forall(*arg0); end
  def self.Z3_is_recursive_datatype_sort(*arg0); end
  def self.Z3_is_well_sorted(*arg0); end
  def self.Z3_mk_abs(*arg0); end
  def self.Z3_mk_add(*arg0); end
  def self.Z3_mk_and(*arg0); end
  def self.Z3_mk_array_default(*arg0); end
  def self.Z3_mk_array_sort(*arg0); end
  def self.Z3_mk_as_array(*arg0); end
  def self.Z3_mk_ast_map(*arg0); end
  def self.Z3_mk_ast_vector(*arg0); end
  def self.Z3_mk_bit2bool(*arg0); end
  def self.Z3_mk_bool_sort(*arg0); end
  def self.Z3_mk_bound(*arg0); end
  def self.Z3_mk_bv2int(*arg0); end
  def self.Z3_mk_bv_sort(*arg0); end
  def self.Z3_mk_bvadd(*arg0); end
  def self.Z3_mk_bvadd_no_overflow(*arg0); end
  def self.Z3_mk_bvadd_no_underflow(*arg0); end
  def self.Z3_mk_bvand(*arg0); end
  def self.Z3_mk_bvashr(*arg0); end
  def self.Z3_mk_bvlshr(*arg0); end
  def self.Z3_mk_bvmul(*arg0); end
  def self.Z3_mk_bvmul_no_overflow(*arg0); end
  def self.Z3_mk_bvmul_no_underflow(*arg0); end
  def self.Z3_mk_bvnand(*arg0); end
  def self.Z3_mk_bvneg(*arg0); end
  def self.Z3_mk_bvneg_no_overflow(*arg0); end
  def self.Z3_mk_bvnor(*arg0); end
  def self.Z3_mk_bvnot(*arg0); end
  def self.Z3_mk_bvor(*arg0); end
  def self.Z3_mk_bvredand(*arg0); end
  def self.Z3_mk_bvredor(*arg0); end
  def self.Z3_mk_bvsdiv(*arg0); end
  def self.Z3_mk_bvsdiv_no_overflow(*arg0); end
  def self.Z3_mk_bvsge(*arg0); end
  def self.Z3_mk_bvsgt(*arg0); end
  def self.Z3_mk_bvshl(*arg0); end
  def self.Z3_mk_bvsle(*arg0); end
  def self.Z3_mk_bvslt(*arg0); end
  def self.Z3_mk_bvsmod(*arg0); end
  def self.Z3_mk_bvsrem(*arg0); end
  def self.Z3_mk_bvsub(*arg0); end
  def self.Z3_mk_bvsub_no_overflow(*arg0); end
  def self.Z3_mk_bvsub_no_underflow(*arg0); end
  def self.Z3_mk_bvudiv(*arg0); end
  def self.Z3_mk_bvuge(*arg0); end
  def self.Z3_mk_bvugt(*arg0); end
  def self.Z3_mk_bvule(*arg0); end
  def self.Z3_mk_bvult(*arg0); end
  def self.Z3_mk_bvurem(*arg0); end
  def self.Z3_mk_bvxnor(*arg0); end
  def self.Z3_mk_bvxor(*arg0); end
  def self.Z3_mk_char(*arg0); end
  def self.Z3_mk_char_from_bv(*arg0); end
  def self.Z3_mk_char_is_digit(*arg0); end
  def self.Z3_mk_char_le(*arg0); end
  def self.Z3_mk_char_sort(*arg0); end
  def self.Z3_mk_char_to_bv(*arg0); end
  def self.Z3_mk_char_to_int(*arg0); end
  def self.Z3_mk_concat(*arg0); end
  def self.Z3_mk_config(*arg0); end
  def self.Z3_mk_const(*arg0); end
  def self.Z3_mk_const_array(*arg0); end
  def self.Z3_mk_context(*arg0); end
  def self.Z3_mk_context_rc(*arg0); end
  def self.Z3_mk_datatype_sort(*arg0); end
  def self.Z3_mk_distinct(*arg0); end
  def self.Z3_mk_div(*arg0); end
  def self.Z3_mk_divides(*arg0); end
  def self.Z3_mk_empty_set(*arg0); end
  def self.Z3_mk_eq(*arg0); end
  def self.Z3_mk_ext_rotate_left(*arg0); end
  def self.Z3_mk_ext_rotate_right(*arg0); end
  def self.Z3_mk_extract(*arg0); end
  def self.Z3_mk_false(*arg0); end
  def self.Z3_mk_finite_domain_sort(*arg0); end
  def self.Z3_mk_fixedpoint(*arg0); end
  def self.Z3_mk_fpa_abs(*arg0); end
  def self.Z3_mk_fpa_add(*arg0); end
  def self.Z3_mk_fpa_div(*arg0); end
  def self.Z3_mk_fpa_eq(*arg0); end
  def self.Z3_mk_fpa_fma(*arg0); end
  def self.Z3_mk_fpa_fp(*arg0); end
  def self.Z3_mk_fpa_geq(*arg0); end
  def self.Z3_mk_fpa_gt(*arg0); end
  def self.Z3_mk_fpa_inf(*arg0); end
  def self.Z3_mk_fpa_is_infinite(*arg0); end
  def self.Z3_mk_fpa_is_nan(*arg0); end
  def self.Z3_mk_fpa_is_negative(*arg0); end
  def self.Z3_mk_fpa_is_normal(*arg0); end
  def self.Z3_mk_fpa_is_positive(*arg0); end
  def self.Z3_mk_fpa_is_subnormal(*arg0); end
  def self.Z3_mk_fpa_is_zero(*arg0); end
  def self.Z3_mk_fpa_leq(*arg0); end
  def self.Z3_mk_fpa_lt(*arg0); end
  def self.Z3_mk_fpa_max(*arg0); end
  def self.Z3_mk_fpa_min(*arg0); end
  def self.Z3_mk_fpa_mul(*arg0); end
  def self.Z3_mk_fpa_nan(*arg0); end
  def self.Z3_mk_fpa_neg(*arg0); end
  def self.Z3_mk_fpa_numeral_double(*arg0); end
  def self.Z3_mk_fpa_numeral_int(*arg0); end
  def self.Z3_mk_fpa_numeral_int64_uint64(*arg0); end
  def self.Z3_mk_fpa_numeral_int_uint(*arg0); end
  def self.Z3_mk_fpa_rem(*arg0); end
  def self.Z3_mk_fpa_round_nearest_ties_to_away(*arg0); end
  def self.Z3_mk_fpa_round_nearest_ties_to_even(*arg0); end
  def self.Z3_mk_fpa_round_to_integral(*arg0); end
  def self.Z3_mk_fpa_round_toward_negative(*arg0); end
  def self.Z3_mk_fpa_round_toward_positive(*arg0); end
  def self.Z3_mk_fpa_round_toward_zero(*arg0); end
  def self.Z3_mk_fpa_rounding_mode_sort(*arg0); end
  def self.Z3_mk_fpa_sort(*arg0); end
  def self.Z3_mk_fpa_sort_128(*arg0); end
  def self.Z3_mk_fpa_sort_16(*arg0); end
  def self.Z3_mk_fpa_sort_32(*arg0); end
  def self.Z3_mk_fpa_sort_64(*arg0); end
  def self.Z3_mk_fpa_sort_double(*arg0); end
  def self.Z3_mk_fpa_sort_half(*arg0); end
  def self.Z3_mk_fpa_sort_quadruple(*arg0); end
  def self.Z3_mk_fpa_sort_single(*arg0); end
  def self.Z3_mk_fpa_sqrt(*arg0); end
  def self.Z3_mk_fpa_sub(*arg0); end
  def self.Z3_mk_fpa_to_fp_bv(*arg0); end
  def self.Z3_mk_fpa_to_fp_float(*arg0); end
  def self.Z3_mk_fpa_to_fp_int_real(*arg0); end
  def self.Z3_mk_fpa_to_fp_real(*arg0); end
  def self.Z3_mk_fpa_to_fp_signed(*arg0); end
  def self.Z3_mk_fpa_to_fp_unsigned(*arg0); end
  def self.Z3_mk_fpa_to_ieee_bv(*arg0); end
  def self.Z3_mk_fpa_to_real(*arg0); end
  def self.Z3_mk_fpa_to_sbv(*arg0); end
  def self.Z3_mk_fpa_to_ubv(*arg0); end
  def self.Z3_mk_fpa_zero(*arg0); end
  def self.Z3_mk_fresh_const(*arg0); end
  def self.Z3_mk_full_set(*arg0); end
  def self.Z3_mk_ge(*arg0); end
  def self.Z3_mk_goal(*arg0); end
  def self.Z3_mk_gt(*arg0); end
  def self.Z3_mk_iff(*arg0); end
  def self.Z3_mk_implies(*arg0); end
  def self.Z3_mk_int(*arg0); end
  def self.Z3_mk_int2bv(*arg0); end
  def self.Z3_mk_int2real(*arg0); end
  def self.Z3_mk_int64(*arg0); end
  def self.Z3_mk_int_sort(*arg0); end
  def self.Z3_mk_int_symbol(*arg0); end
  def self.Z3_mk_int_to_str(*arg0); end
  def self.Z3_mk_is_int(*arg0); end
  def self.Z3_mk_ite(*arg0); end
  def self.Z3_mk_le(*arg0); end
  def self.Z3_mk_linear_order(*arg0); end
  def self.Z3_mk_lstring(*arg0); end
  def self.Z3_mk_lt(*arg0); end
  def self.Z3_mk_mod(*arg0); end
  def self.Z3_mk_model(*arg0); end
  def self.Z3_mk_mul(*arg0); end
  def self.Z3_mk_not(*arg0); end
  def self.Z3_mk_numeral(*arg0); end
  def self.Z3_mk_optimize(*arg0); end
  def self.Z3_mk_or(*arg0); end
  def self.Z3_mk_params(*arg0); end
  def self.Z3_mk_partial_order(*arg0); end
  def self.Z3_mk_piecewise_linear_order(*arg0); end
  def self.Z3_mk_power(*arg0); end
  def self.Z3_mk_probe(*arg0); end
  def self.Z3_mk_re_allchar(*arg0); end
  def self.Z3_mk_re_complement(*arg0); end
  def self.Z3_mk_re_diff(*arg0); end
  def self.Z3_mk_re_empty(*arg0); end
  def self.Z3_mk_re_full(*arg0); end
  def self.Z3_mk_re_loop(*arg0); end
  def self.Z3_mk_re_power(*arg0); end
  def self.Z3_mk_re_range(*arg0); end
  def self.Z3_mk_real(*arg0); end
  def self.Z3_mk_real2int(*arg0); end
  def self.Z3_mk_real_int64(*arg0); end
  def self.Z3_mk_real_sort(*arg0); end
  def self.Z3_mk_rem(*arg0); end
  def self.Z3_mk_repeat(*arg0); end
  def self.Z3_mk_rotate_left(*arg0); end
  def self.Z3_mk_rotate_right(*arg0); end
  def self.Z3_mk_sbv_to_str(*arg0); end
  def self.Z3_mk_select(*arg0); end
  def self.Z3_mk_seq_foldl(*arg0); end
  def self.Z3_mk_seq_foldli(*arg0); end
  def self.Z3_mk_seq_last_index(*arg0); end
  def self.Z3_mk_seq_map(*arg0); end
  def self.Z3_mk_seq_mapi(*arg0); end
  def self.Z3_mk_seq_nth(*arg0); end
  def self.Z3_mk_set_add(*arg0); end
  def self.Z3_mk_set_complement(*arg0); end
  def self.Z3_mk_set_del(*arg0); end
  def self.Z3_mk_set_difference(*arg0); end
  def self.Z3_mk_set_has_size(*arg0); end
  def self.Z3_mk_set_intersect(*arg0); end
  def self.Z3_mk_set_member(*arg0); end
  def self.Z3_mk_set_sort(*arg0); end
  def self.Z3_mk_set_subset(*arg0); end
  def self.Z3_mk_set_union(*arg0); end
  def self.Z3_mk_sign_ext(*arg0); end
  def self.Z3_mk_simple_solver(*arg0); end
  def self.Z3_mk_solver(*arg0); end
  def self.Z3_mk_solver_for_logic(*arg0); end
  def self.Z3_mk_solver_from_tactic(*arg0); end
  def self.Z3_mk_store(*arg0); end
  def self.Z3_mk_str_le(*arg0); end
  def self.Z3_mk_str_lt(*arg0); end
  def self.Z3_mk_str_to_int(*arg0); end
  def self.Z3_mk_string_from_code(*arg0); end
  def self.Z3_mk_string_symbol(*arg0); end
  def self.Z3_mk_string_to_code(*arg0); end
  def self.Z3_mk_sub(*arg0); end
  def self.Z3_mk_tactic(*arg0); end
  def self.Z3_mk_transitive_closure(*arg0); end
  def self.Z3_mk_tree_order(*arg0); end
  def self.Z3_mk_true(*arg0); end
  def self.Z3_mk_type_variable(*arg0); end
  def self.Z3_mk_ubv_to_str(*arg0); end
  def self.Z3_mk_unary_minus(*arg0); end
  def self.Z3_mk_uninterpreted_sort(*arg0); end
  def self.Z3_mk_unsigned_int(*arg0); end
  def self.Z3_mk_unsigned_int64(*arg0); end
  def self.Z3_mk_xor(*arg0); end
  def self.Z3_mk_zero_ext(*arg0); end
  def self.Z3_model_dec_ref(*arg0); end
  def self.Z3_model_eval(*arg0); end
  def self.Z3_model_extrapolate(*arg0); end
  def self.Z3_model_get_const_decl(*arg0); end
  def self.Z3_model_get_const_interp(*arg0); end
  def self.Z3_model_get_func_decl(*arg0); end
  def self.Z3_model_get_func_interp(*arg0); end
  def self.Z3_model_get_num_consts(*arg0); end
  def self.Z3_model_get_num_funcs(*arg0); end
  def self.Z3_model_get_num_sorts(*arg0); end
  def self.Z3_model_get_sort(*arg0); end
  def self.Z3_model_get_sort_universe(*arg0); end
  def self.Z3_model_has_interp(*arg0); end
  def self.Z3_model_inc_ref(*arg0); end
  def self.Z3_model_to_string(*arg0); end
  def self.Z3_model_translate(*arg0); end
  def self.Z3_optimize_assert(*arg0); end
  def self.Z3_optimize_assert_and_track(*arg0); end
  def self.Z3_optimize_assert_soft(*arg0); end
  def self.Z3_optimize_check(*arg0); end
  def self.Z3_optimize_dec_ref(*arg0); end
  def self.Z3_optimize_from_file(*arg0); end
  def self.Z3_optimize_from_string(*arg0); end
  def self.Z3_optimize_get_assertions(*arg0); end
  def self.Z3_optimize_get_help(*arg0); end
  def self.Z3_optimize_get_lower(*arg0); end
  def self.Z3_optimize_get_lower_as_vector(*arg0); end
  def self.Z3_optimize_get_model(*arg0); end
  def self.Z3_optimize_get_objectives(*arg0); end
  def self.Z3_optimize_get_param_descrs(*arg0); end
  def self.Z3_optimize_get_reason_unknown(*arg0); end
  def self.Z3_optimize_get_statistics(*arg0); end
  def self.Z3_optimize_get_unsat_core(*arg0); end
  def self.Z3_optimize_get_upper(*arg0); end
  def self.Z3_optimize_get_upper_as_vector(*arg0); end
  def self.Z3_optimize_inc_ref(*arg0); end
  def self.Z3_optimize_maximize(*arg0); end
  def self.Z3_optimize_minimize(*arg0); end
  def self.Z3_optimize_pop(*arg0); end
  def self.Z3_optimize_push(*arg0); end
  def self.Z3_optimize_set_initial_value(*arg0); end
  def self.Z3_optimize_set_params(*arg0); end
  def self.Z3_optimize_to_string(*arg0); end
  def self.Z3_param_descrs_dec_ref(*arg0); end
  def self.Z3_param_descrs_get_kind(*arg0); end
  def self.Z3_param_descrs_get_name(*arg0); end
  def self.Z3_param_descrs_inc_ref(*arg0); end
  def self.Z3_param_descrs_size(*arg0); end
  def self.Z3_param_descrs_to_string(*arg0); end
  def self.Z3_params_dec_ref(*arg0); end
  def self.Z3_params_inc_ref(*arg0); end
  def self.Z3_params_set_bool(*arg0); end
  def self.Z3_params_set_double(*arg0); end
  def self.Z3_params_set_symbol(*arg0); end
  def self.Z3_params_set_uint(*arg0); end
  def self.Z3_params_to_string(*arg0); end
  def self.Z3_params_validate(*arg0); end
  def self.Z3_pattern_to_string(*arg0); end
  def self.Z3_polynomial_subresultants(*arg0); end
  def self.Z3_probe_and(*arg0); end
  def self.Z3_probe_apply(*arg0); end
  def self.Z3_probe_const(*arg0); end
  def self.Z3_probe_dec_ref(*arg0); end
  def self.Z3_probe_eq(*arg0); end
  def self.Z3_probe_ge(*arg0); end
  def self.Z3_probe_get_descr(*arg0); end
  def self.Z3_probe_gt(*arg0); end
  def self.Z3_probe_inc_ref(*arg0); end
  def self.Z3_probe_le(*arg0); end
  def self.Z3_probe_lt(*arg0); end
  def self.Z3_probe_not(*arg0); end
  def self.Z3_probe_or(*arg0); end
  def self.Z3_qe_lite(*arg0); end
  def self.Z3_rcf_add(*arg0); end
  def self.Z3_rcf_coefficient(*arg0); end
  def self.Z3_rcf_del(*arg0); end
  def self.Z3_rcf_div(*arg0); end
  def self.Z3_rcf_eq(*arg0); end
  def self.Z3_rcf_extension_index(*arg0); end
  def self.Z3_rcf_ge(*arg0); end
  def self.Z3_rcf_gt(*arg0); end
  def self.Z3_rcf_infinitesimal_name(*arg0); end
  def self.Z3_rcf_inv(*arg0); end
  def self.Z3_rcf_is_algebraic(*arg0); end
  def self.Z3_rcf_is_infinitesimal(*arg0); end
  def self.Z3_rcf_is_rational(*arg0); end
  def self.Z3_rcf_is_transcendental(*arg0); end
  def self.Z3_rcf_le(*arg0); end
  def self.Z3_rcf_lt(*arg0); end
  def self.Z3_rcf_mk_e(*arg0); end
  def self.Z3_rcf_mk_infinitesimal(*arg0); end
  def self.Z3_rcf_mk_pi(*arg0); end
  def self.Z3_rcf_mk_rational(*arg0); end
  def self.Z3_rcf_mk_small_int(*arg0); end
  def self.Z3_rcf_mul(*arg0); end
  def self.Z3_rcf_neg(*arg0); end
  def self.Z3_rcf_neq(*arg0); end
  def self.Z3_rcf_num_coefficients(*arg0); end
  def self.Z3_rcf_num_sign_condition_coefficients(*arg0); end
  def self.Z3_rcf_num_sign_conditions(*arg0); end
  def self.Z3_rcf_num_to_decimal_string(*arg0); end
  def self.Z3_rcf_num_to_string(*arg0); end
  def self.Z3_rcf_power(*arg0); end
  def self.Z3_rcf_sign_condition_coefficient(*arg0); end
  def self.Z3_rcf_sign_condition_sign(*arg0); end
  def self.Z3_rcf_sub(*arg0); end
  def self.Z3_rcf_transcendental_name(*arg0); end
  def self.Z3_reset_memory(*arg0); end
  def self.Z3_set_error_handler(*arg0); end
  def self.Z3_set_param_value(*arg0); end
  def self.Z3_simplifier_get_descr(*arg0); end
  def self.Z3_simplify(*arg0); end
  def self.Z3_simplify_ex(*arg0); end
  def self.Z3_simplify_get_help(*arg0); end
  def self.Z3_simplify_get_param_descrs(*arg0); end
  def self.Z3_solver_assert(*arg0); end
  def self.Z3_solver_assert_and_track(*arg0); end
  def self.Z3_solver_check(*arg0); end
  def self.Z3_solver_congruence_explain(*arg0); end
  def self.Z3_solver_congruence_next(*arg0); end
  def self.Z3_solver_congruence_root(*arg0); end
  def self.Z3_solver_cube(*arg0); end
  def self.Z3_solver_dec_ref(*arg0); end
  def self.Z3_solver_from_file(*arg0); end
  def self.Z3_solver_from_string(*arg0); end
  def self.Z3_solver_get_assertions(*arg0); end
  def self.Z3_solver_get_consequences(*arg0); end
  def self.Z3_solver_get_help(*arg0); end
  def self.Z3_solver_get_model(*arg0); end
  def self.Z3_solver_get_non_units(*arg0); end
  def self.Z3_solver_get_num_scopes(*arg0); end
  def self.Z3_solver_get_param_descrs(*arg0); end
  def self.Z3_solver_get_proof(*arg0); end
  def self.Z3_solver_get_reason_unknown(*arg0); end
  def self.Z3_solver_get_statistics(*arg0); end
  def self.Z3_solver_get_trail(*arg0); end
  def self.Z3_solver_get_units(*arg0); end
  def self.Z3_solver_get_unsat_core(*arg0); end
  def self.Z3_solver_import_model_converter(*arg0); end
  def self.Z3_solver_inc_ref(*arg0); end
  def self.Z3_solver_interrupt(*arg0); end
  def self.Z3_solver_pop(*arg0); end
  def self.Z3_solver_propagate_register(*arg0); end
  def self.Z3_solver_push(*arg0); end
  def self.Z3_solver_reset(*arg0); end
  def self.Z3_solver_set_initial_value(*arg0); end
  def self.Z3_solver_set_params(*arg0); end
  def self.Z3_solver_solve_for(*arg0); end
  def self.Z3_solver_to_dimacs_string(*arg0); end
  def self.Z3_solver_to_string(*arg0); end
  def self.Z3_stats_dec_ref(*arg0); end
  def self.Z3_stats_get_double_value(*arg0); end
  def self.Z3_stats_get_key(*arg0); end
  def self.Z3_stats_get_uint_value(*arg0); end
  def self.Z3_stats_inc_ref(*arg0); end
  def self.Z3_stats_is_double(*arg0); end
  def self.Z3_stats_is_uint(*arg0); end
  def self.Z3_stats_size(*arg0); end
  def self.Z3_stats_to_string(*arg0); end
  def self.Z3_tactic_and_then(*arg0); end
  def self.Z3_tactic_apply(*arg0); end
  def self.Z3_tactic_apply_ex(*arg0); end
  def self.Z3_tactic_cond(*arg0); end
  def self.Z3_tactic_dec_ref(*arg0); end
  def self.Z3_tactic_fail(*arg0); end
  def self.Z3_tactic_fail_if(*arg0); end
  def self.Z3_tactic_fail_if_not_decided(*arg0); end
  def self.Z3_tactic_get_descr(*arg0); end
  def self.Z3_tactic_get_help(*arg0); end
  def self.Z3_tactic_get_param_descrs(*arg0); end
  def self.Z3_tactic_inc_ref(*arg0); end
  def self.Z3_tactic_or_else(*arg0); end
  def self.Z3_tactic_par_and_then(*arg0); end
  def self.Z3_tactic_repeat(*arg0); end
  def self.Z3_tactic_skip(*arg0); end
  def self.Z3_tactic_try_for(*arg0); end
  def self.Z3_tactic_using_params(*arg0); end
  def self.Z3_tactic_when(*arg0); end
  def self.Z3_toggle_warning_messages(*arg0); end
  def self.Z3_translate(*arg0); end
  def self.Z3_update_param_value(*arg0); end
  def self.attach_function(name, arg_types, return_type); end
  def self.map_type(t); end
  extend FFI::Library
end
module Z3::LowLevel
  def self._ctx_pointer; end
  def self.add_const_interp(model, func_decl, ast); end
  def self.add_func_interp(model, func_decl, ast); end
  def self.algebraic_add(ast1, ast2); end
  def self.algebraic_div(ast1, ast2); end
  def self.algebraic_eq(ast1, ast2); end
  def self.algebraic_ge(ast1, ast2); end
  def self.algebraic_get_i(ast); end
  def self.algebraic_get_poly(ast); end
  def self.algebraic_gt(ast1, ast2); end
  def self.algebraic_is_neg(ast); end
  def self.algebraic_is_pos(ast); end
  def self.algebraic_is_value(ast); end
  def self.algebraic_is_zero(ast); end
  def self.algebraic_le(ast1, ast2); end
  def self.algebraic_lt(ast1, ast2); end
  def self.algebraic_mul(ast1, ast2); end
  def self.algebraic_neq(ast1, ast2); end
  def self.algebraic_power(ast, num); end
  def self.algebraic_root(ast, num); end
  def self.algebraic_sign(ast); end
  def self.algebraic_sub(ast1, ast2); end
  def self.apply_result_dec_ref(apply_result); end
  def self.apply_result_get_num_subgoals(apply_result); end
  def self.apply_result_get_subgoal(apply_result, num); end
  def self.apply_result_inc_ref(apply_result); end
  def self.apply_result_to_string(apply_result); end
  def self.ast_map_contains(ast_map, ast); end
  def self.ast_map_dec_ref(ast_map); end
  def self.ast_map_erase(ast_map, ast); end
  def self.ast_map_find(ast_map, ast); end
  def self.ast_map_inc_ref(ast_map); end
  def self.ast_map_insert(ast_map, ast1, ast2); end
  def self.ast_map_keys(ast_map); end
  def self.ast_map_reset(ast_map); end
  def self.ast_map_size(ast_map); end
  def self.ast_map_to_string(ast_map); end
  def self.ast_to_string(ast); end
  def self.ast_vector_dec_ref(ast_vector); end
  def self.ast_vector_get(ast_vector, num); end
  def self.ast_vector_inc_ref(ast_vector); end
  def self.ast_vector_push(ast_vector, ast); end
  def self.ast_vector_resize(ast_vector, num); end
  def self.ast_vector_set(ast_vector, num, ast); end
  def self.ast_vector_size(ast_vector); end
  def self.ast_vector_to_string(ast_vector); end
  def self.ast_vector_translate(ast_vector, context); end
  def self.asts_vector(args); end
  def self.constructor_num_fields(constructor); end
  def self.datatype_update_field(func_decl, ast1, ast2); end
  def self.dec_ref(ast); end
  def self.del_config(config); end
  def self.del_constructor(constructor); end
  def self.del_constructor_list(constructor_list); end
  def self.del_context; end
  def self.disable_trace(str); end
  def self.enable_concurrent_dec_ref; end
  def self.enable_trace(str); end
  def self.eval_smtlib2_string(str); end
  def self.finalize_memory; end
  def self.fixedpoint_add_cover(fixedpoint, num, func_decl, ast); end
  def self.fixedpoint_add_invariant(fixedpoint, func_decl, ast); end
  def self.fixedpoint_add_rule(fixedpoint, ast, sym); end
  def self.fixedpoint_assert(fixedpoint, ast); end
  def self.fixedpoint_dec_ref(fixedpoint); end
  def self.fixedpoint_from_file(fixedpoint, str); end
  def self.fixedpoint_from_string(fixedpoint, str); end
  def self.fixedpoint_get_answer(fixedpoint); end
  def self.fixedpoint_get_assertions(fixedpoint); end
  def self.fixedpoint_get_cover_delta(fixedpoint, num, func_decl); end
  def self.fixedpoint_get_ground_sat_answer(fixedpoint); end
  def self.fixedpoint_get_help(fixedpoint); end
  def self.fixedpoint_get_num_levels(fixedpoint, func_decl); end
  def self.fixedpoint_get_param_descrs(fixedpoint); end
  def self.fixedpoint_get_reachable(fixedpoint, func_decl); end
  def self.fixedpoint_get_reason_unknown(fixedpoint); end
  def self.fixedpoint_get_rule_names_along_trace(fixedpoint); end
  def self.fixedpoint_get_rules(fixedpoint); end
  def self.fixedpoint_get_rules_along_trace(fixedpoint); end
  def self.fixedpoint_get_statistics(fixedpoint); end
  def self.fixedpoint_inc_ref(fixedpoint); end
  def self.fixedpoint_query(fixedpoint, ast); end
  def self.fixedpoint_query_from_lvl(fixedpoint, ast, num); end
  def self.fixedpoint_register_relation(fixedpoint, func_decl); end
  def self.fixedpoint_set_params(fixedpoint, params); end
  def self.fixedpoint_update_rule(fixedpoint, ast, sym); end
  def self.fpa_get_ebits(sort); end
  def self.fpa_get_numeral_exponent_bv(ast, bool); end
  def self.fpa_get_numeral_exponent_string(ast, bool); end
  def self.fpa_get_numeral_sign_bv(ast); end
  def self.fpa_get_numeral_significand_bv(ast); end
  def self.fpa_get_numeral_significand_string(ast); end
  def self.fpa_get_sbits(sort); end
  def self.fpa_is_numeral_inf(ast); end
  def self.fpa_is_numeral_nan(ast); end
  def self.fpa_is_numeral_negative(ast); end
  def self.fpa_is_numeral_normal(ast); end
  def self.fpa_is_numeral_positive(ast); end
  def self.fpa_is_numeral_subnormal(ast); end
  def self.fpa_is_numeral_zero(ast); end
  def self.func_entry_dec_ref(func_entry); end
  def self.func_entry_get_arg(func_entry, num); end
  def self.func_entry_get_num_args(func_entry); end
  def self.func_entry_get_value(func_entry); end
  def self.func_entry_inc_ref(func_entry); end
  def self.func_interp_add_entry(func_interp, ast_vector, ast); end
  def self.func_interp_dec_ref(func_interp); end
  def self.func_interp_get_arity(func_interp); end
  def self.func_interp_get_else(func_interp); end
  def self.func_interp_get_entry(func_interp, num); end
  def self.func_interp_get_num_entries(func_interp); end
  def self.func_interp_inc_ref(func_interp); end
  def self.func_interp_set_else(func_interp, ast); end
  def self.get_algebraic_number_lower(ast, num); end
  def self.get_algebraic_number_upper(ast, num); end
  def self.get_app_arg(app, num); end
  def self.get_app_decl(app); end
  def self.get_app_num_args(app); end
  def self.get_arity(func_decl); end
  def self.get_array_arity(sort); end
  def self.get_array_sort_domain(sort); end
  def self.get_array_sort_domain_n(sort, num); end
  def self.get_array_sort_range(sort); end
  def self.get_as_array_func_decl(ast); end
  def self.get_ast_hash(ast); end
  def self.get_ast_id(ast); end
  def self.get_ast_kind(ast); end
  def self.get_bool_value(ast); end
  def self.get_bv_sort_size(sort); end
  def self.get_datatype_sort_constructor(sort, num); end
  def self.get_datatype_sort_constructor_accessor(sort, num1, num2); end
  def self.get_datatype_sort_num_constructors(sort); end
  def self.get_datatype_sort_recognizer(sort, num); end
  def self.get_decl_ast_parameter(func_decl, num); end
  def self.get_decl_double_parameter(func_decl, num); end
  def self.get_decl_func_decl_parameter(func_decl, num); end
  def self.get_decl_int_parameter(func_decl, num); end
  def self.get_decl_kind(func_decl); end
  def self.get_decl_name(func_decl); end
  def self.get_decl_num_parameters(func_decl); end
  def self.get_decl_parameter_kind(func_decl, num); end
  def self.get_decl_rational_parameter(func_decl, num); end
  def self.get_decl_sort_parameter(func_decl, num); end
  def self.get_decl_symbol_parameter(func_decl, num); end
  def self.get_denominator(ast); end
  def self.get_depth(ast); end
  def self.get_domain(func_decl, num); end
  def self.get_domain_size(func_decl); end
  def self.get_error_code; end
  def self.get_full_version; end
  def self.get_func_decl_id(func_decl); end
  def self.get_global_param_descrs; end
  def self.get_index_value(ast); end
  def self.get_num_probes; end
  def self.get_num_simplifiers; end
  def self.get_num_tactics; end
  def self.get_numeral_binary_string(ast); end
  def self.get_numeral_decimal_string(ast, num); end
  def self.get_numeral_double(ast); end
  def self.get_numeral_string(ast); end
  def self.get_numerator(ast); end
  def self.get_pattern(pattern, num); end
  def self.get_pattern_num_terms(pattern); end
  def self.get_probe_name(num); end
  def self.get_quantifier_body(ast); end
  def self.get_quantifier_bound_name(ast, num); end
  def self.get_quantifier_bound_sort(ast, num); end
  def self.get_quantifier_id(ast); end
  def self.get_quantifier_no_pattern_ast(ast, num); end
  def self.get_quantifier_num_bound(ast); end
  def self.get_quantifier_num_no_patterns(ast); end
  def self.get_quantifier_num_patterns(ast); end
  def self.get_quantifier_pattern_ast(ast, num); end
  def self.get_quantifier_skolem_id(ast); end
  def self.get_quantifier_weight(ast); end
  def self.get_range(func_decl); end
  def self.get_re_sort_basis(sort); end
  def self.get_relation_arity(sort); end
  def self.get_relation_column(sort, num); end
  def self.get_seq_sort_basis(sort); end
  def self.get_simplifier_name(num); end
  def self.get_sort(ast); end
  def self.get_sort_id(sort); end
  def self.get_sort_kind(sort); end
  def self.get_sort_name(sort); end
  def self.get_string_length(ast); end
  def self.get_symbol_int(sym); end
  def self.get_symbol_kind(sym); end
  def self.get_symbol_string(sym); end
  def self.get_tactic_name(num); end
  def self.get_tuple_sort_field_decl(sort, num); end
  def self.get_tuple_sort_mk_decl(sort); end
  def self.get_tuple_sort_num_fields(sort); end
  def self.get_version; end
  def self.global_param_reset_all; end
  def self.global_param_set(str1, str2); end
  def self.goal_assert(goal, ast); end
  def self.goal_convert_model(goal, model); end
  def self.goal_dec_ref(goal); end
  def self.goal_depth(goal); end
  def self.goal_formula(goal, num); end
  def self.goal_inc_ref(goal); end
  def self.goal_inconsistent(goal); end
  def self.goal_is_decided_sat(goal); end
  def self.goal_is_decided_unsat(goal); end
  def self.goal_num_exprs(goal); end
  def self.goal_precision(goal); end
  def self.goal_reset(goal); end
  def self.goal_size(goal); end
  def self.goal_to_dimacs_string(goal, bool); end
  def self.goal_to_string(goal); end
  def self.goal_translate(goal, context); end
  def self.inc_ref(ast); end
  def self.interrupt; end
  def self.is_algebraic_number(ast); end
  def self.is_app(ast); end
  def self.is_as_array(ast); end
  def self.is_char_sort(sort); end
  def self.is_eq_ast(ast1, ast2); end
  def self.is_eq_func_decl(func_decl1, func_decl2); end
  def self.is_eq_sort(sort1, sort2); end
  def self.is_ground(ast); end
  def self.is_lambda(ast); end
  def self.is_numeral_ast(ast); end
  def self.is_quantifier_exists(ast); end
  def self.is_quantifier_forall(ast); end
  def self.is_recursive_datatype_sort(sort); end
  def self.is_well_sorted(ast); end
  def self.mk_abs(ast); end
  def self.mk_add(asts); end
  def self.mk_and(asts); end
  def self.mk_array_default(ast); end
  def self.mk_array_sort(sort1, sort2); end
  def self.mk_as_array(func_decl); end
  def self.mk_ast_map; end
  def self.mk_ast_vector; end
  def self.mk_bit2bool(num, ast); end
  def self.mk_bool_sort; end
  def self.mk_bound(num, sort); end
  def self.mk_bv2int(ast, bool); end
  def self.mk_bv_sort(num); end
  def self.mk_bvadd(ast1, ast2); end
  def self.mk_bvadd_no_overflow(ast1, ast2, bool); end
  def self.mk_bvadd_no_underflow(ast1, ast2); end
  def self.mk_bvand(ast1, ast2); end
  def self.mk_bvashr(ast1, ast2); end
  def self.mk_bvlshr(ast1, ast2); end
  def self.mk_bvmul(ast1, ast2); end
  def self.mk_bvmul_no_overflow(ast1, ast2, bool); end
  def self.mk_bvmul_no_underflow(ast1, ast2); end
  def self.mk_bvnand(ast1, ast2); end
  def self.mk_bvneg(ast); end
  def self.mk_bvneg_no_overflow(ast); end
  def self.mk_bvnor(ast1, ast2); end
  def self.mk_bvnot(ast); end
  def self.mk_bvor(ast1, ast2); end
  def self.mk_bvredand(ast); end
  def self.mk_bvredor(ast); end
  def self.mk_bvsdiv(ast1, ast2); end
  def self.mk_bvsdiv_no_overflow(ast1, ast2); end
  def self.mk_bvsge(ast1, ast2); end
  def self.mk_bvsgt(ast1, ast2); end
  def self.mk_bvshl(ast1, ast2); end
  def self.mk_bvsle(ast1, ast2); end
  def self.mk_bvslt(ast1, ast2); end
  def self.mk_bvsmod(ast1, ast2); end
  def self.mk_bvsrem(ast1, ast2); end
  def self.mk_bvsub(ast1, ast2); end
  def self.mk_bvsub_no_overflow(ast1, ast2); end
  def self.mk_bvsub_no_underflow(ast1, ast2, bool); end
  def self.mk_bvudiv(ast1, ast2); end
  def self.mk_bvuge(ast1, ast2); end
  def self.mk_bvugt(ast1, ast2); end
  def self.mk_bvule(ast1, ast2); end
  def self.mk_bvult(ast1, ast2); end
  def self.mk_bvurem(ast1, ast2); end
  def self.mk_bvxnor(ast1, ast2); end
  def self.mk_bvxor(ast1, ast2); end
  def self.mk_char(num); end
  def self.mk_char_from_bv(ast); end
  def self.mk_char_is_digit(ast); end
  def self.mk_char_le(ast1, ast2); end
  def self.mk_char_sort; end
  def self.mk_char_to_bv(ast); end
  def self.mk_char_to_int(ast); end
  def self.mk_concat(ast1, ast2); end
  def self.mk_config; end
  def self.mk_const(sym, sort); end
  def self.mk_const_array(sort, ast); end
  def self.mk_context; end
  def self.mk_context_rc(config); end
  def self.mk_datatype_sort(sym); end
  def self.mk_distinct(asts); end
  def self.mk_div(ast1, ast2); end
  def self.mk_divides(ast1, ast2); end
  def self.mk_empty_set(sort); end
  def self.mk_eq(ast1, ast2); end
  def self.mk_ext_rotate_left(ast1, ast2); end
  def self.mk_ext_rotate_right(ast1, ast2); end
  def self.mk_extract(num1, num2, ast); end
  def self.mk_false; end
  def self.mk_finite_domain_sort(sym, num); end
  def self.mk_fixedpoint; end
  def self.mk_fpa_abs(ast); end
  def self.mk_fpa_add(ast1, ast2, ast3); end
  def self.mk_fpa_div(ast1, ast2, ast3); end
  def self.mk_fpa_eq(ast1, ast2); end
  def self.mk_fpa_fma(ast1, ast2, ast3, ast4); end
  def self.mk_fpa_fp(ast1, ast2, ast3); end
  def self.mk_fpa_geq(ast1, ast2); end
  def self.mk_fpa_gt(ast1, ast2); end
  def self.mk_fpa_inf(sort, bool); end
  def self.mk_fpa_is_infinite(ast); end
  def self.mk_fpa_is_nan(ast); end
  def self.mk_fpa_is_negative(ast); end
  def self.mk_fpa_is_normal(ast); end
  def self.mk_fpa_is_positive(ast); end
  def self.mk_fpa_is_subnormal(ast); end
  def self.mk_fpa_is_zero(ast); end
  def self.mk_fpa_leq(ast1, ast2); end
  def self.mk_fpa_lt(ast1, ast2); end
  def self.mk_fpa_max(ast1, ast2); end
  def self.mk_fpa_min(ast1, ast2); end
  def self.mk_fpa_mul(ast1, ast2, ast3); end
  def self.mk_fpa_nan(sort); end
  def self.mk_fpa_neg(ast); end
  def self.mk_fpa_numeral_double(double, sort); end
  def self.mk_fpa_numeral_int(num, sort); end
  def self.mk_fpa_numeral_int64_uint64(bool, num1, num2, sort); end
  def self.mk_fpa_numeral_int_uint(bool, num1, num2, sort); end
  def self.mk_fpa_rem(ast1, ast2); end
  def self.mk_fpa_round_nearest_ties_to_away; end
  def self.mk_fpa_round_nearest_ties_to_even; end
  def self.mk_fpa_round_to_integral(ast1, ast2); end
  def self.mk_fpa_round_toward_negative; end
  def self.mk_fpa_round_toward_positive; end
  def self.mk_fpa_round_toward_zero; end
  def self.mk_fpa_rounding_mode_sort; end
  def self.mk_fpa_sort(num1, num2); end
  def self.mk_fpa_sort_128; end
  def self.mk_fpa_sort_16; end
  def self.mk_fpa_sort_32; end
  def self.mk_fpa_sort_64; end
  def self.mk_fpa_sort_double; end
  def self.mk_fpa_sort_half; end
  def self.mk_fpa_sort_quadruple; end
  def self.mk_fpa_sort_single; end
  def self.mk_fpa_sqrt(ast1, ast2); end
  def self.mk_fpa_sub(ast1, ast2, ast3); end
  def self.mk_fpa_to_fp_bv(ast, sort); end
  def self.mk_fpa_to_fp_float(ast1, ast2, sort); end
  def self.mk_fpa_to_fp_int_real(ast1, ast2, ast3, sort); end
  def self.mk_fpa_to_fp_real(ast1, ast2, sort); end
  def self.mk_fpa_to_fp_signed(ast1, ast2, sort); end
  def self.mk_fpa_to_fp_unsigned(ast1, ast2, sort); end
  def self.mk_fpa_to_ieee_bv(ast); end
  def self.mk_fpa_to_real(ast); end
  def self.mk_fpa_to_sbv(ast1, ast2, num); end
  def self.mk_fpa_to_ubv(ast1, ast2, num); end
  def self.mk_fpa_zero(sort, bool); end
  def self.mk_fresh_const(str, sort); end
  def self.mk_full_set(sort); end
  def self.mk_ge(ast1, ast2); end
  def self.mk_goal(bool1, bool2, bool3); end
  def self.mk_gt(ast1, ast2); end
  def self.mk_iff(ast1, ast2); end
  def self.mk_implies(ast1, ast2); end
  def self.mk_int(num, sort); end
  def self.mk_int2bv(num, ast); end
  def self.mk_int2real(ast); end
  def self.mk_int64(num, sort); end
  def self.mk_int_sort; end
  def self.mk_int_symbol(num); end
  def self.mk_int_to_str(ast); end
  def self.mk_is_int(ast); end
  def self.mk_ite(ast1, ast2, ast3); end
  def self.mk_le(ast1, ast2); end
  def self.mk_linear_order(sort, num); end
  def self.mk_lstring(num, str); end
  def self.mk_lt(ast1, ast2); end
  def self.mk_mod(ast1, ast2); end
  def self.mk_model; end
  def self.mk_mul(asts); end
  def self.mk_not(ast); end
  def self.mk_numeral(str, sort); end
  def self.mk_optimize; end
  def self.mk_or(asts); end
  def self.mk_params; end
  def self.mk_partial_order(sort, num); end
  def self.mk_piecewise_linear_order(sort, num); end
  def self.mk_power(ast1, ast2); end
  def self.mk_probe(str); end
  def self.mk_re_allchar(sort); end
  def self.mk_re_complement(ast); end
  def self.mk_re_diff(ast1, ast2); end
  def self.mk_re_empty(sort); end
  def self.mk_re_full(sort); end
  def self.mk_re_loop(ast, num1, num2); end
  def self.mk_re_power(ast, num); end
  def self.mk_re_range(ast1, ast2); end
  def self.mk_real(num1, num2); end
  def self.mk_real2int(ast); end
  def self.mk_real_int64(num1, num2); end
  def self.mk_real_sort; end
  def self.mk_rem(ast1, ast2); end
  def self.mk_repeat(num, ast); end
  def self.mk_rotate_left(num, ast); end
  def self.mk_rotate_right(num, ast); end
  def self.mk_sbv_to_str(ast); end
  def self.mk_select(ast1, ast2); end
  def self.mk_seq_foldl(ast1, ast2, ast3); end
  def self.mk_seq_foldli(ast1, ast2, ast3, ast4); end
  def self.mk_seq_last_index(ast1, ast2); end
  def self.mk_seq_map(ast1, ast2); end
  def self.mk_seq_mapi(ast1, ast2, ast3); end
  def self.mk_seq_nth(ast1, ast2); end
  def self.mk_set_add(ast1, ast2); end
  def self.mk_set_complement(ast); end
  def self.mk_set_del(ast1, ast2); end
  def self.mk_set_difference(ast1, ast2); end
  def self.mk_set_has_size(ast1, ast2); end
  def self.mk_set_intersect(asts); end
  def self.mk_set_member(ast1, ast2); end
  def self.mk_set_sort(sort); end
  def self.mk_set_subset(ast1, ast2); end
  def self.mk_set_union(asts); end
  def self.mk_sign_ext(num, ast); end
  def self.mk_simple_solver; end
  def self.mk_solver; end
  def self.mk_solver_for_logic(sym); end
  def self.mk_solver_from_tactic(tactic); end
  def self.mk_store(ast1, ast2, ast3); end
  def self.mk_str_le(ast1, ast2); end
  def self.mk_str_lt(ast1, ast2); end
  def self.mk_str_to_int(ast); end
  def self.mk_string_from_code(ast); end
  def self.mk_string_symbol(str); end
  def self.mk_string_to_code(ast); end
  def self.mk_sub(asts); end
  def self.mk_tactic(str); end
  def self.mk_transitive_closure(func_decl); end
  def self.mk_tree_order(sort, num); end
  def self.mk_true; end
  def self.mk_type_variable(sym); end
  def self.mk_ubv_to_str(ast); end
  def self.mk_unary_minus(ast); end
  def self.mk_uninterpreted_sort(sym); end
  def self.mk_unsigned_int(num, sort); end
  def self.mk_unsigned_int64(num, sort); end
  def self.mk_xor(ast1, ast2); end
  def self.mk_zero_ext(num, ast); end
  def self.model_dec_ref(model); end
  def self.model_eval(model, ast, model_completion); end
  def self.model_extrapolate(model, ast); end
  def self.model_get_const_decl(model, num); end
  def self.model_get_const_interp(model, func_decl); end
  def self.model_get_func_decl(model, num); end
  def self.model_get_func_interp(model, func_decl); end
  def self.model_get_num_consts(model); end
  def self.model_get_num_funcs(model); end
  def self.model_get_num_sorts(model); end
  def self.model_get_sort(model, num); end
  def self.model_get_sort_universe(model, sort); end
  def self.model_has_interp(model, func_decl); end
  def self.model_inc_ref(model); end
  def self.model_to_string(model); end
  def self.model_translate(model, context); end
  def self.optimize_assert(optimize, ast); end
  def self.optimize_assert_and_track(optimize, ast1, ast2); end
  def self.optimize_assert_soft(optimize, ast, str, sym); end
  def self.optimize_check(optimize, asts); end
  def self.optimize_dec_ref(optimize); end
  def self.optimize_from_file(optimize, str); end
  def self.optimize_from_string(optimize, str); end
  def self.optimize_get_assertions(optimize); end
  def self.optimize_get_help(optimize); end
  def self.optimize_get_lower(optimize, num); end
  def self.optimize_get_lower_as_vector(optimize, num); end
  def self.optimize_get_model(optimize); end
  def self.optimize_get_objectives(optimize); end
  def self.optimize_get_param_descrs(optimize); end
  def self.optimize_get_reason_unknown(optimize); end
  def self.optimize_get_statistics(optimize); end
  def self.optimize_get_unsat_core(optimize); end
  def self.optimize_get_upper(optimize, num); end
  def self.optimize_get_upper_as_vector(optimize, num); end
  def self.optimize_inc_ref(optimize); end
  def self.optimize_maximize(optimize, ast); end
  def self.optimize_minimize(optimize, ast); end
  def self.optimize_pop(optimize); end
  def self.optimize_push(optimize); end
  def self.optimize_set_initial_value(optimize, ast1, ast2); end
  def self.optimize_set_params(optimize, params); end
  def self.optimize_to_string(optimize); end
  def self.param_descrs_dec_ref(param_descrs); end
  def self.param_descrs_get_kind(param_descrs, sym); end
  def self.param_descrs_get_name(param_descrs, num); end
  def self.param_descrs_inc_ref(param_descrs); end
  def self.param_descrs_size(param_descrs); end
  def self.param_descrs_to_string(param_descrs); end
  def self.params_dec_ref(params); end
  def self.params_inc_ref(params); end
  def self.params_set_bool(params, sym, bool); end
  def self.params_set_double(params, sym, double); end
  def self.params_set_symbol(params, sym1, sym2); end
  def self.params_set_uint(params, sym, num); end
  def self.params_to_string(params); end
  def self.params_validate(params, param_descrs); end
  def self.pattern_to_string(pattern); end
  def self.polynomial_subresultants(ast1, ast2, ast3); end
  def self.probe_and(probe1, probe2); end
  def self.probe_apply(probe, goal); end
  def self.probe_const(double); end
  def self.probe_dec_ref(probe); end
  def self.probe_eq(probe1, probe2); end
  def self.probe_ge(probe1, probe2); end
  def self.probe_get_descr(str); end
  def self.probe_gt(probe1, probe2); end
  def self.probe_inc_ref(probe); end
  def self.probe_le(probe1, probe2); end
  def self.probe_lt(probe1, probe2); end
  def self.probe_not(probe); end
  def self.probe_or(probe1, probe2); end
  def self.qe_lite(ast_vector, ast); end
  def self.rcf_add(num1, num2); end
  def self.rcf_coefficient(num1, num2); end
  def self.rcf_del(num); end
  def self.rcf_div(num1, num2); end
  def self.rcf_eq(num1, num2); end
  def self.rcf_extension_index(num); end
  def self.rcf_ge(num1, num2); end
  def self.rcf_gt(num1, num2); end
  def self.rcf_infinitesimal_name(num); end
  def self.rcf_inv(num); end
  def self.rcf_is_algebraic(num); end
  def self.rcf_is_infinitesimal(num); end
  def self.rcf_is_rational(num); end
  def self.rcf_is_transcendental(num); end
  def self.rcf_le(num1, num2); end
  def self.rcf_lt(num1, num2); end
  def self.rcf_mk_e; end
  def self.rcf_mk_infinitesimal; end
  def self.rcf_mk_pi; end
  def self.rcf_mk_rational(str); end
  def self.rcf_mk_small_int(num); end
  def self.rcf_mul(num1, num2); end
  def self.rcf_neg(num); end
  def self.rcf_neq(num1, num2); end
  def self.rcf_num_coefficients(num); end
  def self.rcf_num_sign_condition_coefficients(num1, num2); end
  def self.rcf_num_sign_conditions(num); end
  def self.rcf_num_to_decimal_string(num1, num2); end
  def self.rcf_num_to_string(num, bool1, bool2); end
  def self.rcf_power(num1, num2); end
  def self.rcf_sign_condition_coefficient(num1, num2, num3); end
  def self.rcf_sign_condition_sign(num1, num2); end
  def self.rcf_sub(num1, num2); end
  def self.rcf_transcendental_name(num); end
  def self.reset_memory; end
  def self.set_error_handler(&block); end
  def self.set_param_value(config, str1, str2); end
  def self.simplifier_get_descr(str); end
  def self.simplify(ast); end
  def self.simplify_ex(ast, params); end
  def self.simplify_get_help; end
  def self.simplify_get_param_descrs; end
  def self.solver_assert(solver, ast); end
  def self.solver_assert_and_track(solver, ast1, ast2); end
  def self.solver_check(solver); end
  def self.solver_congruence_explain(solver, ast1, ast2); end
  def self.solver_congruence_next(solver, ast); end
  def self.solver_congruence_root(solver, ast); end
  def self.solver_cube(solver, ast_vector, num); end
  def self.solver_dec_ref(solver); end
  def self.solver_from_file(solver, str); end
  def self.solver_from_string(solver, str); end
  def self.solver_get_assertions(solver); end
  def self.solver_get_consequences(solver, ast_vector1, ast_vector2, ast_vector3); end
  def self.solver_get_help(solver); end
  def self.solver_get_model(solver); end
  def self.solver_get_non_units(solver); end
  def self.solver_get_num_scopes(solver); end
  def self.solver_get_param_descrs(solver); end
  def self.solver_get_proof(solver); end
  def self.solver_get_reason_unknown(solver); end
  def self.solver_get_statistics(solver); end
  def self.solver_get_trail(solver); end
  def self.solver_get_units(solver); end
  def self.solver_get_unsat_core(solver); end
  def self.solver_import_model_converter(solver1, solver2); end
  def self.solver_inc_ref(solver); end
  def self.solver_interrupt(solver); end
  def self.solver_pop(solver, num); end
  def self.solver_propagate_register(solver, ast); end
  def self.solver_push(solver); end
  def self.solver_reset(solver); end
  def self.solver_set_initial_value(solver, ast1, ast2); end
  def self.solver_set_params(solver, params); end
  def self.solver_solve_for(solver, ast_vector1, ast_vector2, ast_vector3); end
  def self.solver_to_dimacs_string(solver, bool); end
  def self.solver_to_string(solver); end
  def self.stats_dec_ref(stats); end
  def self.stats_get_double_value(stats, num); end
  def self.stats_get_key(stats, num); end
  def self.stats_get_uint_value(stats, num); end
  def self.stats_inc_ref(stats); end
  def self.stats_is_double(stats, num); end
  def self.stats_is_uint(stats, num); end
  def self.stats_size(stats); end
  def self.stats_to_string(stats); end
  def self.tactic_and_then(tactic1, tactic2); end
  def self.tactic_apply(tactic, goal); end
  def self.tactic_apply_ex(tactic, goal, params); end
  def self.tactic_cond(probe, tactic1, tactic2); end
  def self.tactic_dec_ref(tactic); end
  def self.tactic_fail; end
  def self.tactic_fail_if(probe); end
  def self.tactic_fail_if_not_decided; end
  def self.tactic_get_descr(str); end
  def self.tactic_get_help(tactic); end
  def self.tactic_get_param_descrs(tactic); end
  def self.tactic_inc_ref(tactic); end
  def self.tactic_or_else(tactic1, tactic2); end
  def self.tactic_par_and_then(tactic1, tactic2); end
  def self.tactic_repeat(tactic, num); end
  def self.tactic_skip; end
  def self.tactic_try_for(tactic, num); end
  def self.tactic_using_params(tactic, params); end
  def self.tactic_when(probe, tactic); end
  def self.toggle_warning_messages(bool); end
  def self.translate(ast, context); end
  def self.unpack_ast_vector(_ast_vector); end
  def self.unpack_statistics(_stats); end
  def self.update_param_value(str1, str2); end
end
class Z3::AST
  def _ast; end
  def arguments; end
  def ast_kind; end
  def eql?(other); end
  def func_decl; end
  def hash; end
  def initialize(_ast); end
  def self.new(*, **); end
  def sexpr; end
  def simplify; end
  def to_s; end
end
class Z3::Context
  def _context; end
  def initialize; end
  def self.instance; end
end
class Z3::Solver
  def _solver; end
  def assert(ast); end
  def assertions; end
  def check; end
  def check_sat_results(r); end
  def initialize; end
  def model; end
  def pop(n = nil); end
  def prove!(ast); end
  def push; end
  def reset; end
  def reset_model!; end
  def satisfiable?; end
  def statistics; end
  def unsatisfiable?; end
end
class Z3::Optimize
  def _optimize; end
  def assert(ast); end
  def assert_soft(ast, weight = nil, id = nil); end
  def assertions; end
  def check(*args); end
  def check_sat_results(r); end
  def initialize; end
  def maximize(ast); end
  def minimize(ast); end
  def model; end
  def pop; end
  def prove!(ast); end
  def push; end
  def reason_unknown; end
  def reset_model!; end
  def satisfiable?; end
  def statistics; end
  def unsatisfiable?; end
end
class Z3::Model
  def !; end
  def [](ast); end
  def _model; end
  def consts; end
  def each; end
  def initialize(_model); end
  def inspect; end
  def model_eval(ast, model_completion = nil); end
  def num_consts; end
  def num_funcs; end
  def num_sorts; end
  def to_s; end
  include Enumerable
end
class Z3::Exception < StandardError
end
class Z3::FuncDecl < Z3::AST
  def arity; end
  def domain(i); end
  def initialize(_ast); end
  def inspect; end
  def name; end
  def range; end
  def self.new(*, **); end
  def to_s; end
end
class Z3::Sort < Z3::AST
  def <(other); end
  def <=(other); end
  def <=>(other); end
  def ==(other); end
  def >(other); end
  def >=(other); end
  def cast(a); end
  def eql?(other); end
  def from_value(v); end
  def hash; end
  def initialize(_ast); end
  def inspect; end
  def new(_ast); end
  def self.from_pointer(_sort); end
  def to_s; end
  def value_class; end
  def var(name); end
  include Comparable
end
class Z3::IntSort < Z3::Sort
  def expr_class; end
  def from_const(val); end
  def initialize; end
  def self.new(*, **); end
end
class Z3::RealSort < Z3::Sort
  def >(other); end
  def expr_class; end
  def from_const(val); end
  def from_value(val); end
  def initialize; end
  def self.new(*, **); end
end
class Z3::BoolSort < Z3::Sort
  def False; end
  def True; end
  def expr_class; end
  def from_const(val); end
  def initialize; end
  def self.new(*, **); end
end
class Z3::BitvecSort < Z3::Sort
  def >(other); end
  def expr_class; end
  def from_const(val); end
  def initialize(n); end
  def inspect; end
  def self.new(*, **); end
  def size; end
  def to_s; end
end
class Z3::FloatSort < Z3::Sort
  def >(other); end
  def ebits; end
  def expr_class; end
  def from_const(val); end
  def initialize(e, s = nil); end
  def inspect; end
  def nan; end
  def negative_infinity; end
  def negative_zero; end
  def positive_infinity; end
  def positive_zero; end
  def sbits; end
  def self.new(*, **); end
  def to_s; end
end
class Z3::RoundingModeSort < Z3::Sort
  def expr_class; end
  def initialize; end
  def inspect; end
  def nearest_ties_away; end
  def nearest_ties_even; end
  def self.new(*, **); end
  def to_s; end
  def towards_negative; end
  def towards_positive; end
  def towards_zero; end
end
class Z3::SetSort < Z3::Sort
  def Empty; end
  def Full; end
  def element_sort; end
  def expr_class; end
  def initialize(element_sort); end
  def inspect; end
  def self.new(*, **); end
  def to_s; end
end
class Z3::ArraySort < Z3::Sort
  def expr_class; end
  def initialize(key_sort, value_sort); end
  def inspect; end
  def key_sort; end
  def self.new(*, **); end
  def to_s; end
  def value_sort; end
end
class Z3::Expr < Z3::AST
  def !=(other); end
  def ==(other); end
  def initialize(_ast, sort); end
  def inspect; end
  def self.Add(*args); end
  def self.And(*args); end
  def self.Distinct(*args); end
  def self.Eq(a, b); end
  def self.Ge(a, b); end
  def self.Gt(a, b); end
  def self.Le(a, b); end
  def self.Lt(a, b); end
  def self.Mul(*args); end
  def self.Or(*args); end
  def self.Sub(*args); end
  def self.Xor(*args); end
  def self.coerce_to_same_sort(*args); end
  def self.new_from_pointer(_ast); end
  def self.sort_for_const(a); end
  def sort; end
end
class Z3::ArithExpr < Z3::Expr
  def *(other); end
  def **(other); end
  def +(other); end
  def -(other); end
  def -@; end
  def /(other); end
  def <(other); end
  def <=(other); end
  def >(other); end
  def >=(other); end
  def abs; end
  def coerce(other); end
  def negative?; end
  def nonzero?; end
  def positive?; end
  def self.Div(a, b); end
  def self.Power(a, b); end
  def self.coerce_to_same_arith_sort(*args); end
  def zero?; end
end
class Z3::IntExpr < Z3::ArithExpr
  def %(other); end
  def mod(other); end
  def rem(other); end
  def self.Mod(a, b); end
  def self.Rem(a, b); end
  def self.coerce_to_same_int_sort(*args); end
  def self.new(*, **); end
  def to_i; end
end
class Z3::RealExpr < Z3::ArithExpr
  def self.new(*, **); end
end
class Z3::BoolExpr < Z3::Expr
  def !; end
  def &(other); end
  def ^(other); end
  def iff(other); end
  def implies(other); end
  def ite(a, b); end
  def self.IfThenElse(a, b, c); end
  def self.Iff(a, b); end
  def self.Implies(a, b); end
  def self.coerce_to_same_bool_sort(*args); end
  def self.new(*, **); end
  def to_b; end
  def |(other); end
  def ~; end
end
class Z3::BitvecExpr < Z3::Expr
  def !; end
  def %(other); end
  def &(other); end
  def *(other); end
  def +(other); end
  def -(other); end
  def -@; end
  def /(other); end
  def <(other); end
  def <<(other); end
  def <=(other); end
  def >(other); end
  def >=(other); end
  def >>(other); end
  def ^(other); end
  def abs; end
  def add_no_overflow?(other); end
  def add_no_underflow?(other); end
  def coerce(other); end
  def concat(other); end
  def div_no_overflow?(other); end
  def extract(hi, lo); end
  def lshift(other); end
  def mul_no_overflow?(other); end
  def mul_no_underflow?(other); end
  def nand(other); end
  def neg_no_overflow?; end
  def negative?; end
  def nonzero?; end
  def nor(other); end
  def positive?; end
  def rotate_left(num); end
  def rotate_right(num); end
  def rshift(other); end
  def self.LShift(a, b); end
  def self.Nand(*args); end
  def self.Nor(*args); end
  def self.SignedAddNoOverflow(a, b); end
  def self.SignedAddNoUnderflow(a, b); end
  def self.SignedDiv(a, b); end
  def self.SignedDivNoOverflow(a, b); end
  def self.SignedGe(a, b); end
  def self.SignedGt(a, b); end
  def self.SignedLe(a, b); end
  def self.SignedLt(a, b); end
  def self.SignedMod(a, b); end
  def self.SignedMulNoOverflow(a, b); end
  def self.SignedMulNoUnderflow(a, b); end
  def self.SignedNegNoOverflow(a); end
  def self.SignedRShift(a, b); end
  def self.SignedRem(a, b); end
  def self.UnsignedAddNoOverflow(a, b); end
  def self.UnsignedDiv(a, b); end
  def self.UnsignedGe(a, b); end
  def self.UnsignedGt(a, b); end
  def self.UnsignedLe(a, b); end
  def self.UnsignedLt(a, b); end
  def self.UnsignedMulNoOverflow(a, b); end
  def self.UnsignedRShift(a, b); end
  def self.UnsignedRem(a, b); end
  def self.Xnor(*args); end
  def self.coerce_to_same_bv_sort(*args); end
  def self.new(*, **); end
  def sign_ext(size); end
  def signed_add_no_overflow?(other); end
  def signed_add_no_underflow?(other); end
  def signed_div(other); end
  def signed_div_no_overflow?(other); end
  def signed_ge(other); end
  def signed_gt(other); end
  def signed_le(other); end
  def signed_lshift(other); end
  def signed_lt(other); end
  def signed_mod(other); end
  def signed_mul_no_overflow?(other); end
  def signed_mul_no_underflow?(other); end
  def signed_neg_no_overflow?; end
  def signed_rem(other); end
  def signed_rshift(other); end
  def unsigned_add_no_overflow?(other); end
  def unsigned_add_no_underflow?(other); end
  def unsigned_div(other); end
  def unsigned_div_no_overflow?(other); end
  def unsigned_ge(other); end
  def unsigned_gt(other); end
  def unsigned_le(other); end
  def unsigned_lshift(other); end
  def unsigned_lt(other); end
  def unsigned_mul_no_overflow?(other); end
  def unsigned_mul_no_underflow?(other); end
  def unsigned_neg_no_overflow?; end
  def unsigned_rem(other); end
  def unsigned_rshift(other); end
  def xnor(other); end
  def zero?; end
  def zero_ext(size); end
  def |(other); end
  def ~; end
end
class Z3::FloatExpr < Z3::Expr
  def !=(other); end
  def -@; end
  def <(other); end
  def <=(other); end
  def ==(other); end
  def >(other); end
  def >=(other); end
  def abs; end
  def add(other, mode); end
  def div(other, mode); end
  def exponent_string(biased); end
  def infinite?; end
  def max(other); end
  def min(other); end
  def mul(other, mode); end
  def nan?; end
  def negative?; end
  def nonzero?; end
  def normal?; end
  def positive?; end
  def rem(other); end
  def self.Add(a, b, m); end
  def self.Div(a, b, m); end
  def self.Eq(a, b); end
  def self.Ge(a, b); end
  def self.Gt(a, b); end
  def self.Le(a, b); end
  def self.Lt(a, b); end
  def self.Max(a, b); end
  def self.Min(a, b); end
  def self.Mul(a, b, m); end
  def self.Ne(a, b); end
  def self.Rem(a, b); end
  def self.Sub(a, b, m); end
  def self.coerce_to_mode_sort(m); end
  def self.coerce_to_same_float_sort(*args); end
  def self.new(*, **); end
  def significand_string; end
  def sub(other, mode); end
  def subnormal?; end
  def zero?; end
end
class Z3::RoundingModeExpr < Z3::Expr
  def self.new(*, **); end
end
class Z3::SetExpr < Z3::Expr
  def complement; end
  def difference(other); end
  def element_sort; end
  def include?(element); end
  def intersection(other); end
  def is_subset_of(other); end
  def is_superset_of(other); end
  def self.Difference(a, b); end
  def self.Intersection(*args); end
  def self.Subset(a, b); end
  def self.Union(*args); end
  def self.coerce_to_same_set_sort(*args); end
  def self.new(*, **); end
  def union(other); end
end
class Z3::ArrayExpr < Z3::Expr
  def [](key); end
  def key_sort; end
  def select(key); end
  def self.new(*, **); end
  def store(key, value); end
  def value_sort; end
end
class Z3::Tactic
  def and_then(other); end
  def help; end
  def initialize(_tactic); end
  def or_else(other); end
  def parallel_and_then(other); end
  def repeat(num); end
  def self.cond(probe, tactic1, tactic2); end
  def self.fail; end
  def self.fail_if(probe); end
  def self.fail_if_not_decided; end
  def self.skip; end
  def self.when(probe, tactic); end
  def tactic; end
  def try_for(time_ms); end
end
class Z3::Probe
  def !; end
  def &(other); end
  def <(other); end
  def <=(other); end
  def ==(other); end
  def >(other); end
  def >=(other); end
  def _probe; end
  def apply(goal); end
  def initialize(_probe); end
  def self.const(num); end
  def self.named(str); end
  def self.names; end
  def |(other); end
  def ~; end
end
class Z3::Goal
  def _goal; end
  def assert(ast); end
  def decided_sat?; end
  def decided_unsat?; end
  def depth; end
  def formula(num); end
  def inconsistent?; end
  def initialize(_goal); end
  def num_exprs; end
  def precision; end
  def reset; end
  def self.new(models = nil, unsat_cores = nil, proofs = nil); end
  def size; end
  def to_s; end
end
class Z3::Printer
  def format(a); end
  def format_app(a); end
  def format_ast(a); end
end
class Z3::Printer::PrintedExpr
  def enforce_parentheses; end
  def initialize(str, priority = nil); end
  def priority; end
  def str; end
  def to_s; end
end
module EqualityHacks
  def !=(other); end
  def ==(other); end
end
module CompareHacks
  def !=(other); end
  def <(other); end
  def <=(other); end
  def ==(other); end
  def >(other); end
  def >=(other); end
end
class TrueClass
end
class FalseClass
end
class Rational < Numeric
end
class Integer < Numeric
end
class Float < Numeric
end
